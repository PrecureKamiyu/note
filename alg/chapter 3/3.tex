\documentclass[a4paper, 10pt]{ctexart} %ä¸­æ–‡æ”¯æŒ
\usepackage{float}              %é˜²æ­¢æµ®åŠ¨å…ƒç´ æµ®åŠ¨
\usepackage{rotating}           %æ—‹è½¬å›¾ç‰‡
\usepackage{amsfonts}           %å¯¹æŸä¸€äº›å­—ä½“ä¹‹æ”¯æŒ
\usepackage{mathrsfs}           %mathscr e.g.
\usepackage{amsmath}          %æ•°å­¦å…¬å¼
\usepackage{amsthm}             %å®šä¹‰, å®šç†, è¯æ˜, ä¾‹å­ç¯å¢ƒçš„æ”¯æŒ
%ä½¿ç”¨æ–¹æ³•:
%\newtheorem{environment name}{caption}
%æ¯”å¦‚ \newtheorem{example}{è¿™æ˜¯ä¾‹å­}
%æ•ˆæœ \begin{example} xxx \end{example} -> è¿™æ˜¯ä¾‹å­ 1 xxx
%proofå°±ä¸éœ€è¦äº†
\usepackage{graphicx}           %æ’å…¥å›¾ç‰‡
\usepackage[left=1.25in,right=1.25in,top=1in,bottom=1in]{geometry}   %ç”¨æ¥æ’ç‰ˆçš„
\usepackage[]{color}            %ç»™éƒ¨åˆ†æ–‡æœ¬ä¸Šè‰²çš„
%\usepackage{algorithm}          %å†™ä¼ªä»£ç çš„
%\usepackage{algorithmic}       %åŒä¸Š
%\usepackage{algorithm}
%\usepackage{algorithmicx}
%\usepackage{algpseudocode}
%\usepackage{minted}
\usepackage{amssymb}            %ç”¨æ¥åŠ å…¥ä¸€äº›æ•°å­¦ç¬¦å·, æ¯”å¦‚è¯´ $\varnothing$
\usepackage{titlesec}
\usepackage{fontspec}           %ä¸çŸ¥é“ç”¨æ¥å¹²å˜›çš„
\usepackage{hyperref}           %ç”Ÿæˆå¯è·³è½¬çš„ä¹¦ç­¾
% -------------------------------
%\setmonofont{Ubuntu Mono}       %?
%\usemintedstyle{custommanni}    %è®¾ç½®mintedæ’å…¥ä»£ç çš„é£æ ¼
\titleformat*{\section}{\huge\bfseries}             %ç®¡ç†titleçš„å­—ä½“å’Œå¤§å°
\titleformat*{\subsection}{\Large\bfseries}         %bfserieså°±æ˜¯é»˜è®¤çš„å­—ä½“.
\titleformat*{\subsubsection}{\large\bfseries}
% -------------------------------
\newtheorem{theorem}{Theorem}
\newtheorem{example}{Example}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{remark}{Remark}
\newtheorem{corollary}{Comment}
\newtheorem{proposition}{Proposition}
\pagestyle{plain}
\title{Divide\ and \ Conquer\ ç¬¬äºŒæ¬¡è¯¾\thanks{å¯èƒ½æ˜¯ç¬¬äºŒæ¬¡è¯¾}}
\author{You \and me}

\begin{document}
\maketitle
\tableofcontents
ä»Šå¤©æˆ‘ä»¬é¢å¯¹çš„æ˜¯Divide and Conquerçš„ç®—æ³•æ€æƒ³, åŸºæœ¬å°±æ˜¯é€’å½’è°ƒç”¨å˜›.
ä¸€èˆ¬éƒ½ä¼šæœ‰é€’å½’æ–¹ç¨‹: $T\left(n\right) = a T\left(n / b\right) + f\left(n\right)$
è¿™æ ·çš„ä¸œè¥¿. 

å‰é¢æˆ‘ä»¬å·²ç»å­¦ä¹ äº†å¾ˆå¤šåˆ†æä¸Šé¢é€’å½’æ–¹ç¨‹çš„å¤æ‚åº¦çš„æ–¹æ³•, ä»¥åŠå­¦ä¹ äº†ä¸¤ä¸ªç»å…¸æ¡ˆä¾‹: å½’å¹¶æ’åºä»¥åŠå¿«é€Ÿæ’åº. ä»Šå¤©è®²çš„ä¾æ—§æ˜¯è¿™äº›ä¸œè¥¿.


\section{what is divide and conquer?}
divide and conquer is a method to solve a question, to design an algorithm.
It has two parts as whose name have suggested: Divide and Conquer. The basic idea is to divide the problem into some subproblems and try to conquer those 
subproblems. 

The precedure consists of three parts in fact. Let's make a list.

\begin{enumerate}
    \item Divide: to divide the problem.
    \item Conquer: try to solve the subproblems
    \item Combine: given the solution of some subproblems, to derive the 
    the solution to the original one from those solutions.
\end{enumerate}

So the outline of the analysis of a divide-and-conquer algorithm is that to find the recurrence function of 
the algorithm, and by using some previous knowledge of recurrence function, to figure the time complexity of the 
algorithm, that is to know: given the scale of input, let's say $n$, the order of $T(n)$ , which stands for 
the time complexity.

It is clear that the operations of division and combination take time. Say that they take $D\left(n\right)$ and $C \left(n\right)$ 
separately. And we assume that the operation of division divides a $n$ scale problem into $a$ subproblems with $n  / b$. Then we can write out 
the recurrence function:
\begin{align*}
    T\left(n\right) = 
    \begin{cases}
        \Theta \left(1\right)  & \text{if} n \le c\\
        a T\left( n  / b \right) + D\left(n\right) + C\left(n\right)&  \text{otherwise}
    \end{cases}
\end{align*}

\begin{corollary}
    There is actually a much more complex and annoying situation, that is what if the division divide 
    a problem into one subproblem with scale $n \times \frac{1}{3}$ and a subproblem with scale $n \times \frac{2}{3}$. So you can not 
    use master theorem.

    How are you going to work this out?
\end{corollary}

\section{æ’åºæ³•}
A sort is an operation to or, let's say, a process of some `unordered sequence', to make it `ordered'. 
\begin{example}
    Give a sequence `$52 , 49 , 80 ,  36  , 14 , 58 ,  61 , 23 , 97 , 75$', after the ordering,
    the output is 
    \begin{align*}
        14, 23 , 36  , 49 , 52 ,  58 
    \end{align*}
    and so on and so on.
\end{example}

\paragraph{the defintion of ordering} We can describe the above intuitive expression with more acuracy.
Let's put it straight. We are given a sequence $\left\{R_{1}, \cdots   ,R_{n}\right\}$. (You know how to precisely define 
a sequence. Check some mathematical analysis textbooks.)

And the sequence has a corresponding sequence of key
\begin{align*}
    \left\{K_{1} , \cdots  , K_{n}\right\}
\end{align*}
which act as an identificator, to determine the position of the order of some $R_{i}$, that is there exists a relation on those keys. (and the relation is partial order relation, and moreover is 
linearly ordered.):
\begin{align*}
    K_{p_{1}} \le K_{p_{2}} \le \cdots  \le K_{p_{n}}
\end{align*}

So what sort do is to reordering the sequence $\left\{R_{1} \cdots \right\}$ into $\left\{ R_{p_{1}}, \cdots \right\}$

\paragraph{The interior ordering and external ordering} When scale of the sequence is so big that the memory can not 
hold it viz. the ordering can not complete within the memory. 
The sort algorithms that work within the memory are called interior sort.

\subsection{the classification of ordering algorithms}
We call the collection of $R$ which are in order as `ordered area', and respectively call the rest the `unordered area'. 

\begin{definition}[round] 
    a round within the algorithm is the operation that enlarge the number of $R_{i}$ that is in order.
\end{definition}

There are 4 basic catergory of ordering algorithm. Let's make a list: 
\begin{enumerate}
    \item insert: to insert some member of unordered area to ordered area
    \item select: to select the highest or lowest in unordered area, and put it right next to order area.
    \item swap: to swap the target in unordered area, and swap it with some other $R$ in unordered area, making it ordered.
    \item merge: given two or more ordered sequence, to merge them into a bigger ordered sequence.
\end{enumerate}
\begin{corollary}
\textcolor{red}{note that the definitions of {\bfseries select} and {\bfseries swap} are wrong}
\end{corollary}

Base on the idea of divide and conquer, we have some prototype of the ordering algorithm. 

One is to select a position basing on which we divide the problem (the description here might be not very clear). 
Another is to choose a member of the sequence, base on which we make a partition where
members that are bigger than it are placed behind while the members that are smaller than it 
are placed in the front.

And the combination operations are indeed different accordingly. 

\subsection{merge sort}
As we have stated, we choose a position can divide the sequence accordingly, by which we get two 
subproblems. 
\begin{definition}
    given the sequence, let describe in the form of array
    $A[i,\cdots, j]$. We divide it with the position $k$. 

    Then we have $A[ i, \cdots    , k  ] A \left[  k + 1 ,  \cdots  , j\right]$ ,where $k  = \displaystyle  \frac{ i  +j}{ 2}$. Then we solve  the subproblems
    recurrently and combine them afterwards. That is merge sort.
\end{definition}
\noindent The key is that we assume the 
$A\left[ i , \cdots ,k \right] , A[k+1 , \cdots  ,j]$ are ordered. And we combine them to make to 
a larger sequence that is ordered.
\subsubsection{code}
Figure~\ref{fig:merge1} shows the pseudo-code of merge sort. The main idea 
is merge, which use the idea of pointers.
\begin{figure}[]
    \centering
    \includegraphics[scale = 0.5]{merge1.png}
    \caption{code of merge sort}
    \label{fig:merge1}
\end{figure}
\subsubsection{analysis}
We can easily write out the recurrence function of the 
algorithm: 
\begin{align*}
    T \left( n\right)  = 
    \begin{cases}
        2  T(  n / 2) + n & \\
        O\left(1\right) & n< c
    \end{cases}
\end{align*}
Because, operation that combine the two sequences need 
$\Theta \left( n\right)$ costs. And then we use master theorem:
\begin{align*}
T \left( n\right)  =  \Theta \left( n \log n\right)
\end{align*}
\subsection{å¿«é€Ÿæ’åº}
the sketch of the algorithm is that 
we choose a $x$ and parition the sequence 
basing on it. 
Then we have two subproblems and deal with them 
in the same way. Then we will have the answer.
\subsubsection{the code}
\begin{figure}[htbp]
    \centering
    \includegraphics[scale = 0.5]{quicksort1.png}
    \caption{the pseudo code of quick sort}
    \label{fig:quicksort1}
\end{figure}
Figure~\ref{fig:quicksort1} shows the pseudo code of the quick sort.
\subsubsection{the time complexity analysis}
\paragraph{worst case}The time it takes in the worst case is :
\begin{align*}
    \Theta \left(n ^{2}\right)
\end{align*}
let's say we are given an ordered sequence but in a reverse order. So every partition takes a 
long time, like $\Theta \left(n\right)$ where it have to compare to every other member of the 
sequence. More precisely, for the first chosen $x$, the partition takes $n-1$ operations. For the $i$ th $x$, the partition 
takes $n - i$ operations. 

The time algorithm cost is consequently $\Theta \left(n^{2}\right)$

\paragraph{best case} % (fold)
\label{par:best case}
every time the scale of the subproblems are equal in a best case, which result to that 
the recurrence function is that 
\begin{align*}
    T\left(n \right) =  2 T(n  /2    ) + \Theta \left(n\right)
\end{align*}
We can use master theorem to figure that  $T\left(n\right) = \Theta \left(n \log n\right)$
% paragraph best case (end)

\paragraph{average case} % (fold)
\label{par:average case}
the average case is actually $\Theta \left( n \log n    \right)$ the same to the best case. It is not saying that they have the same costs.

If we consider the scale of subproblems, the `average' can be viewed as follows:
\begin{align*}
    \frac{1}{n} \sum_{s=1} ^{n} \left(T\left(s\right) + T \left(n  -s\right)\right) 
\end{align*}
Because the case where scales differ have actually equal chances to happen. 

Consequently, we have 
\begin{align*}
    T\left(n\right) & = \frac{1}{n} \sum_{ s = 1}  ^{n} \Big(T\left(s\right) + T\left( n -s\right)\Big) + cn\\
    & = \frac{1}{n} \left( 2 T \left(1\right) + \cdots  + 2 T\left( n -1\right) + T \left(n\right) \right) + cn
\end{align*}
Here is some technique we need to use : 
\begin{align*}
    \left(n  - 1\right) T\left(n\right) =  2 T\left(1 \right)  + 2 T\left(2\right)  +\cdots  + 2 T\left(n-1\right) + c n^{2} \tag{1} \\
    \left(n-2\right)  T\left(n - 1\right) =  2 T\left(1\right) + \cdots  + 2 T\left( n  -2   \right) + c \left(n - 1\right) ^{2} \tag{2} 
\end{align*}
substract equation (2) from equation (1) . Anyway, we have 
\begin{align*}
    \left(n  - 1\right) T\left(n\right)  -  \left(n  -2\right)  T\left( n -1\right)  = 2 T\left(n - 1\right) +c \left(2 n - 1\right)  \\
\end{align*}
which leads to 
\begin{align*}
    & \left(n - 1\right) T\left(n\right)   - n T\left( n -1\right) = c \left( 2n -1 \right) \\
    \implies & \frac{T\left(n\right) }{ n}  = T\left( n-1   \right) / \left(  n -1\right) + c \left( \frac{1}{n} + \frac{1}{n-1}\right)
\end{align*}
which allows us to calculate the value of $T\left(n\right) $ recurrently, viz. 
\begin{align*}
    T \left(n\right) / n & = c \left( \frac{1}{n} + \frac{1}{n -1} \right) + c \left( \frac{1}{n-1} + \frac{1}{n-2} \right) + \cdots  + c \left(\frac{1}{2} + 1 \right) + T (1 ) \\
    & = c \left( \frac{1}{n } + \frac{1}{n-1    } + \cdots + \frac{1}{2} \right) + c \left( \frac{1}{n-1} + \frac{1}{n-2} + \cdots   + 1\right)  + T\left(1\right)
\end{align*}
These two parts are same. There is no need to separate them like what we have done here.

Next, we use a asymptotical analysis of Harmony series, viz.
\begin{align*}
    H_{n} & = 1 + \frac{1}{2} + \cdots + \frac{1}{n} \\
    & = \log n + \gamma + \frac{1}{2n}  -\frac{1}{12n ^{2} } + \frac{1}{120 n^{4} } - \varepsilon
\end{align*}
where $ 0 < \varepsilon < \frac{1}{252n ^{6} } $ , and gamma is euler const. Just forget about that. This proposition is too strong. Anyway, it is crystal clear that $H_{n} =  O \left(\log n\right)$. So apparently, 
\begin{align*}
    & T\left(n\right) / n  = c \left(H _{n} - 1\right)  + c H_{n-1}  = O\left(\log n\right)
\end{align*}
then we have 
\begin{align*}
T(n) = O\left(n \log n\right)
\end{align*}

% paragraph average case (end)
\subsubsection{random quick sort}
In the algorithm above, we can notice that the worst case happens when the sequence 
is in reverse order. That is because the chosen $x$ is the first member of the sequence. 
Consequently, a natural way to improve the algorithm, is to randomly choose the $x$, in the
partition operation.

Thus for different sequences, they have the same expectation of the time it consumes.

That was great. 

\paragraph{the code} % (fold)
\label{par:the code}

the code is left to the readers as exercise, because it is 
very easy. Just a slight change.
% paragraph the code (end)

\paragraph{analysis} % (fold)
\label{par:analysis}

Here is some notation: 
\begin{definition}
    $S_{\left(i\right)}$ stands for the $i^{\text{th}}$ smallest element. For example $S_{\left(1\right)}, S_{\left(n\right)}$, the former is smallest member, and latter is the biggest member. 

    $X_{ij}$ is a random variable, defined as follows: 
    The value of $X_{ij}$   
    is equal to the number of the comparison between $i , j$ 
    in the algorithm. 

    Consequently, the comparison made during the algorithm is 
    \begin{align*}
        \sum_{i  =1}  ^{n} \sum_{j > i}  X_{ij}
    \end{align*}
    Note that it is still a random variable.
\end{definition}

Consequently, what we want to know is the expectation of the series above,
viz. 
\begin{align*}
    E \left[ \sum_{i=1} ^{n} \sum_{j > i}  X_{ij} \right] = \sum_{i=1}^{n} \sum_{ j > i}  E\left[ X_{ij} \right]
\end{align*}

Actually the 
$X_{ij}$ can only have the value of 
$0 $ and $ 1$, which leads to that 
$E \left[ X_{ij} \right] =  p_{ij} \times 1 + \left(1-  p_{ij} \right) \times 0$.
So the question is to find $p_{ij}$

In a partition, the chosen $x$ has to be compared to every 
other members in the sequence.
Moreover, once the partition is over, 
$x $ will not be compared again. Now you should know why the value of $X_{ij}$ can only be $1 $ or $0$.

Every operation of partition, actually, will form a partition of 
the sequence. May you can draw some pictures to figure this out.
Anyway, two members, let's say $i$ and $j$, can be compared only when they are 
in `a' same class of the parition (the class is short for equivalent class). 

The analysis can be carried on now. Please take a notice to the next procedure of analysis: 
\begin{enumerate}
    \item Only when $S_{i} , S_{i + 1} , \cdots  , S_{j}$ is in a same class, $S_{(i)}$ and $S_{\left(j\right)}$ can be compared.
    \item Only when $S_{\left(i\right)} $ or $S_{\left(j\right)}$ is chosen as the $x$, these two can be compared.
    \item Moreover, if we choose some $S_{\left(k\right)}$ where $k< i$ or $k > j$, $S_{(i)}, S_{(j)}$ are still possible to be compared.
    \item The probability of $S_{\left(i +k\right)}$ to be chosen as $x$ are equals. So the probability of $S_{\left(i\right)} , S_{\left(j\right)}$ to be chosen as $x$ is 
    \begin{align*}
        \frac{2}{ j   - i + 1}
    \end{align*}
    viz. 
    \begin{align*}
        p_{ij} =  \frac{2}{ j  -i + 1}
    \end{align*}
\end{enumerate}
\begin{remark}
    One might notice that the number of members in the class might not be precisely the $j - i + 1$.
    We just ignore this situation. Why?
\end{remark}

It is available to calculate the expection now. 
\begin{align*}
    \sum_{i=1} ^{n} \sum_{ j >  i }  E \left[ X_{ij} \right] & 
    = \sum_{i=1} ^{n}\sum_{j > i}  \frac{2}{j - i  +1} \\
    & \le \sum_{ i = 1}  ^{n} \sum_{k=1} ^{n  - i + 1} \frac{2}{k} \le 2 \sum_{i=1} ^{n} \sum_{ k =1} ^{n - i  + 1} \frac{1}{k} \\
    & = 2n H_{n} = O\left( n \log n\right)
\end{align*}

Over ! 
% paragraph analysis (end)

\subsection{the lower bound of sort problem}
It describe how fast the sort can be under certain cases.
For example, under the worst case or under the average case.

\begin{definition}
    If a problem has a low bound, for example, $\Omega\left( n\log n\right)$, 
    and if the time complexity of an algorithm is 
    $O \left( n\log n\right)$, 
    then we say that 
    algorithm is optimal.
\end{definition}
\begin{definition}[decision trees]
    A procedure and the all the cases of a sort can be expressed as tree,
    where, the leaf nodes stands for the resulted sequences.
    and the non-leaf nodes stands for the operations of comparsion.

    And moreover, the number of the non-leaf node in a path stand of the 
    comparison it shall take under this case. 
    That is the level of the leaf stands for the number of operations.
\end{definition}

Thus, the low bound of a sort, is the lowest level of a leaf. 


let's say that the decision tree has height $h$ and have $l$ leaves. All the possible resulted sequences are in number of 
$ n !$.

Then we can easily get an inequality :
\begin{align*}
      n ! \le l \le 2 ^{h}
\end{align*}
Then
\begin{align*}
h \ge \log \left( n !\right) = \Omega \left( n \log n\right)
\end{align*} 
We can see that
\footnote{the approximation can be deduced from Stirling formula: $n ! \sim \sqrt{2\pi n} \left( \frac{n}{e}\right) ^{n}$}
, in the worst case, the 
time complexity has a low bound $\Omega \left( n \log n \right)$

%====================================
\paragraph{the average case} % (fold)
\label{par:the average case}
we consider the average length of paths, which is that 
\begin{align*}
    \frac{ \text{total length}}{n !}
\end{align*}
when the decision tree is \textbf{balanced}, the average length above takes minimum. 

\begin{definition}[balanced decision tree]
In a balanced decision tree, every leaf has level either $d$ or $d - 1$, where $d$ is the 
height of the tree.
\end{definition}

Because what we want is a lower bound. So 
only the balanced decision tree is concerned,
which is the minimum, which is, what we want. 

\begin{enumerate}
    \item it is clear that $d = \left\lceil \log  c \right\rceil$, where $c = x_{1} + x_{2}$
    \item $x_{1}$ in level $d - 1$ and $x_{2} $ in level $d$
    \item $x_{1} + \dfrac{x_2}{2} = 2^{d-1}$. $2 ^{d- 1}$ is the number of nodes in 
    level $d  -1$
    \item total length:
    \begin{align*}
        M & = x _{1} \left(d - 1\right)  +x_{2} d  \\ 
        & = \left(2 ^{d} - c     \right) \left(d - 1\right) + 2 \left( c - 2 ^{d-1}\right) d \\
        & = c \left(d - 1\right) + 2 \left( c - 2 ^{d-1}\right) \tag{$d- 1  = \left\lfloor  \log c \right\rfloor$} \\
        & = c \left\lfloor \log  c \right\rfloor + 2 \left(c - 2 ^{\left\lfloor \log c \right\rfloor}\right)
    \end{align*}
    \item $c = n!$ since this is the case when the tree has lowest height. 
    \item We claim that $c  - 2 ^{\left\lfloor \log  c \right\rfloor } \ge \dfrac{c}{2}$ so 
    \begin{align*}
        M / n ! & > \left\lfloor \log n ! \right\rfloor + 1 \\
        & = \Omega \left( n \log  n\right)
    \end{align*}
    \item so the low bound in average case is $\Omega \left( n \log n\right)$
\end{enumerate}
% paragraph the average case (end)

In general, the low bound of sort is $\Omega \left( n\log n\right)$ in all possible cases.
The quick sort is optimal when the const is ignored.

Oh my god! I mean, this is bad. The deduction is like shit.
\section{MAX and MIN é—®é¢˜}
\noindent\textbf{Input}: $n$ ä¸ªäº’å¼‚çš„æ•°ç»„æˆçš„æ•°ç»„ $A$ , ä»¥åŠä¸€ä¸ªæ­£æ•´æ•° $i$

\noindent\textbf{Output}: $B = \left\{ x | \left| A \le x \right| = i \right\}$
for this proposed problem, if it is sovled, then the Max  ã¨ Min can be solved.

æˆ‘ä»¬æƒ³åˆ°çš„æœ€ç®€å•çš„æ–¹æ³•å¾ˆæ˜æ˜¾å°±æ˜¯ç›´æ¥æ’åºç„¶åè¿›è¡Œä¸€ä¸ªé€‰å–, ä½†æ˜¯è¿™æ ·æœªå…æœ‰ç‚¹ç®€é™‹äº†, å¹¶ä¸”æ•ˆç‡ä¹Ÿæ˜¯ä¸€ç‚¹ä¹Ÿä¸ç†æƒ³. So we may tackle the 
simplified problem here: find the Max ã¨ Min.

\subsection{ç®—æ³•1, ä¸ä½¿ç”¨é€’å½’æ–¹ç¨‹}
ä¸€ä¸ªæ˜æ˜¾çš„æƒ³æ³•å°±æ˜¯ç›´æ¥ä»å¤´åˆ°å°¾æ‰«æä¸¤è¾¹, å°±éƒ½æ±‚å‡ºæ¥äº†, æ—¶é—´å¤æ‚åº¦æ˜¯ $2 \left(n-1\right)$ , å…¶ä¸­ $n$ æ˜¯é—®é¢˜çš„è§„æ¨¡, åœ¨è¿™é‡Œæ˜¯æ•°ç»„çš„å¤§å°.
æˆ‘ä»¬è¿™é‡Œèƒ½å¤Ÿç»™å‡ºä¸€ä¸ªç®—æ³•, å…¶æ•ˆç‡æ˜¯ $\displaystyle \left\lfloor \frac{n}{2} \right\rfloor   +  2 \left\lceil \frac{n}{2} \right\rceil$: 

\begin{enumerate}
    \item ä»æ•°ç»„çš„ä¸¤ç«¯å¼€å§‹, ä¸¤ä¸¤æ¯”è¾ƒ, å°†è¾ƒå¤§çš„ä¸€æ–¹æ”¾åœ¨å‰é¢, è¾ƒå°çš„ä¸€æ–¹æ”¾åœ¨åé¢
    \item æˆ‘ä»¬èƒ½å¤ŸçŸ¥é“, æœ€å¤§å€¼ä¸€å®šåœ¨å‰é¢, æœ€å°å€¼ä¸€å®šåœ¨åé¢
    \item æˆ‘ä»¬åˆ†åˆ«æ‰«æå‰é¢å’Œåé¢, å°±èƒ½å¤Ÿå¾—å‡ºæœ€å¤§å€¼å’Œæœ€å°å€¼äº†
\end{enumerate}
æˆ‘ä»¬å¯¹è¿™ä¸ªç®—æ³•è¿›è¡Œä¸€ä¸‹åˆ†æ

1. ä¸­æ‰§è¡Œæ¬¡æ•°å…¶å®åªæœ‰ $\lfloor \dfrac{n}{2} \rfloor$ , 
è¿™æ˜¯å› ä¸ºå½“ $n$ æ˜¯å¥‡æ•°çš„æ—¶å€™, ä¸­é—´çš„æ•°å­—ä¸éœ€è¦å˜åŠ¨, å› ä¸ºç®—è¦å˜åŠ¨ä¹Ÿæ˜¯è‡ªå·±å’Œè‡ªå·±äº¤æ¢
, äºæ˜¯å‘ä¸‹å–æ•´;

3. ä¸­åˆ†åˆ«æ‰«æ $A \left[ 1, \cdots  ,  \lceil \dfrac{n}{2} \rceil \right]$,
ä»¥åŠ $A \left[ \lceil \dfrac{n}{2} \rceil , \cdots   , n \right]$, 
å°±èƒ½åˆ†åˆ«æ±‚å‡ºæœ€å¤§å€¼å’Œæœ€å°å€¼äº†, 
æ¯”è¾ƒçš„æ¬¡æ•°æ˜¯ $2 \lceil \dfrac{n}{2} \rceil$. äºæ˜¯æ—¶é—´å¤æ‚åº¦å°±æ˜¯ 
\begin{align*}
\displaystyle \left\lfloor \frac{n}{2} \right\rfloor   +  2 \left\lceil \frac{n}{2} \right\rceil
\end{align*}

\newpage
è¿™ä¸ªè¯æ˜å¹¶ä¸æ˜¯å¾ˆä¼šæ, è¿™é‡Œç»™å‡ºä¼ªä»£ç¢¼:
\begin{figure}[H]
    \centering
    \includegraphics[scale=0.3]{1.jpg}\caption{ä¸ä½¿ç”¨éæ­¸æ–¹ç¨‹çš„ç®—æ³•}
\end{figure}
\subsection{ç®—æ³•2, ä½¿ç”¨é€’å½’æ–¹ç¨‹}
\begin{enumerate}
    \item line 1 ã¨ 2 are initial value of recurrence function. 
    \item line 6 \& 7 are division. 
    \item line 8 \& 9 are combination.
\end{enumerate}
\begin{figure}[H]
    \centering
    \includegraphics*[scale = 0.3]{2.png}\caption{ä½¿ç”¨éæ­¸æ–¹ç¨‹çš„ç®—æ³•}
\end{figure}

å›¾ä¸­çš„ç®—æ³•æ˜¯ä¸€ä¸ªé€’å½’æ±‚è§£çš„è¿‡ç¨‹, å°†è§„æ¨¡ä¸º $n$ çš„é—®é¢˜è½¬åŒ–ä¸ºä¸¤ä¸ª $n / 2$ çš„é—®é¢˜, 
å³æ±‚å‡ºå‰åŠçš„æœ€å€¼, ååŠçš„æœ€å€¼, è€Œåè¿›è¡Œæ¯”è¾ƒ, å¾—å‡ºæ€»çš„æœ€å€¼
, èƒ½å¤Ÿå¾—å‡º:
\[
T\left(n\right) = 2 T\left(n /2\right) + 2
\]

ä¸‹é¢æˆ‘ä»¬æ¥çœ‹çœ‹è¿™ä¸ªçš„æ—¶é—´å¤æ‚åº¦, è®¾ $n = 2 ^{k}$
(å› ä¸ºè¿™æ ·æ–¹ä¾¿ä¸€ç‚¹) , 
\[
\begin{aligned}
    T\left(n \right)& = 2  T\left(n /2\right) +2 \\
    & = 4 T\left(n / 4\right) + 2 ^{2} +2 \\
    & = 2 ^{3}T\left(n / 8\right) + 2 ^{3} + 2 ^{2} +2 \\
    & = \cdots \\
    & = 2^{k-1} T\left(2\right) + \sum_{i=1} ^{k-1} 2 ^{i}
\end{aligned}
\]
\noindent \textbf{Remarks.} \\
1. $T\left(n\right) = 2 T\left( n /2\right) + 2$ 
åé¢å¸¸æ•°æ˜¯   $2$ , æ˜¯å› ä¸ºæœ€å¤§å€¼å’Œæœ€å°å€¼å„æ¯”è¾ƒä¸€æ¬¡\\ 
2. å¦‚ä½•è®¡ç®—çš„? $2 T\left(n /2 \right) = 
2\left(2 T\left( n /4\right) + 2\right) + 2 
= 4 T\left( n / 4\right) + 2 ^{2 +2} \cdots$\\
3. ä¸å†ç ”ç©¶æœ€å¤§æœ€å°å€¼é€‰æ‹©é—®é¢˜çš„ä¸‹ç•Œå’Œå¹³å‡æƒ…å†µä¸‹é€‰æ‹©çš„ä¸‹ç•Œ 
(ä¸ºä»€ä¹ˆ?\footnote{è¿™å¹¶ä¸æ˜¯ç•™ç»™è¯»è€…æ€è€ƒçš„, æˆ‘æ˜¯çœŸä¸çŸ¥é“ä¸ºä»€ä¹ˆ})

\section{é€‰æ‹©ä¸­ä½æ•°} 
\subsection{é—®é¢˜æè¿°}

\noindent \textbf{Input} : ä¸€ä¸ªé•¿åº¦ä¸º $n$ çš„æ•°ç»„\\
\textbf{Output} : è¿™ä¸ªæ•°ç»„çš„ä¸­ä½æ•°\footnote{
    é€‰å–ç¬¬ $\left\lfloor \dfrac{n+1}{2} \right\rfloor$ å¤§çš„æ•°å­—}
\subsection{ç®—æ³•è®¾è®¡}
ç›´æ¥ç»™å‡ºç®—æ³•:{\sffamily Select (A, i)}çš„å®šä¹‰

å‚æ•° $A , i$, å…¶ä¸­ $A$ æ˜¯æ•°ç»„, $i$ 
å®šä¹‰ä¸º $\left\lfloor \left(n +1\right) / 2 \right\rfloor$, æ„ä¸ºé€‰æ‹©æ•°ç»„ä¸­ç¬¬ $i$ å¤§çš„æ•°å­—
\\
\noindent step1. å°†æˆ‘ä»¬çš„æ•°ç»„åˆ†ä¸ºäº”ä¸ªéƒ¨åˆ†
\\step2. ä½¿ç”¨æ’å…¥æ’åºå°†è¿™ä¸ªäº”ä¸ªéƒ¨åˆ†æ’åº, ä»¥æ­¤é€‰å‡ºäº”ä¸ªä¸­ä½æ•°
\\step3. åœ¨è¿™äº”ä¸ªæ•°å­—ä¸­é€’å½’è°ƒç”¨ç®—æ³• {\sffamily Select}\footnote{Select ä¹‹ä¸­ä½¿ç”¨ Par}, å¾—å‡ºä¸­ä½æ•°, è®°ä¸º $x$ 
\\step4. ä½¿ç”¨å‡½æ•°åˆ’åˆ† {\sffamily Partition}: å°†æ‰€æœ‰å°äº $x$ çš„æ”¾åœ¨å‰é¢, 
å¤§äº $x$ çš„æ”¾åœ¨åé¢. å¹¶ä¸”å¾—åˆ° $x$ çš„ä¸‹æ ‡ $k$
\\step5. å°†ä¸‹æ ‡ $k$ å’Œ $i =  \left\lfloor \dfrac{n+1}{2} \right\rfloor$ æ¯”è¾ƒ
\\å¦‚æœè¯´ $i = k$ åˆ™ OK , å¦‚æœè¯´ $k > i$ , åˆ™åœ¨å‰é¢å¯»æ‰¾ç¬¬ $i$ å¤§çš„æ•°, \\
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.3]{4.png}\caption{}
\end{figure}
å¦‚æœè¯´ $k < i$ åˆ™åœ¨åé¢å¯»æ‰¾ä¸€ä¸ª $i - k$ å¤§çš„æ•°.\\
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.3]{5.png}\caption{}
\end{figure}

\subsection{ä¼ªä»£ç¢¼}
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.3]{3.png}\footnote{è¿™é‡Œéœ€è¦ä¸€äº›ä¿®æ”¹}\caption{}
\end{figure}
è¿™ä¸ªä¸œè¥¿æ˜¯ä¸æ˜¯æ²¡æœ‰è®¾ç½®åˆå§‹æ¡ä»¶é˜¿? æ¯”å¦‚è¯´æˆ‘æœ‰ä¸€ä¸ªé•¿åº¦ä¸º 5 çš„æ•°ç»„, ç„¶åè¾“è¿›å»ä¹‹åè¿˜è¦è°ƒç”¨è¿™ä¸ª 
select å—? æä¸æ‡‚å•Š.

æ€»ä¹‹, è¿™ä¸ªç®—æ³•çš„æµç¨‹å°±æ˜¯, æˆ‘é‡å¤ä¸€ä¸‹ä¸Šé¢çš„è¿™ä¸ªä¸œè¥¿. è¿™ä¸ªç®—æ³•å®é™…ä¸Šæ˜¯å°†, è¿™ä¸ªæ•°ç»„, é¢„å¤„ç†ä¸€ä¸‹, é€‰æ‹©å‡ºä¸€ä¸ªæ€€ç–‘å¯¹è±¡, 
è¿™ä¸ªé¢„å¤„ç†ä½¿ç”¨çš„æ˜¯è¿™ä¸ª insertion sort; è€Œåæ˜¯ divide \& Conquer çš„éƒ¨åˆ†, é‡å¤ä½¿ç”¨ partition å¾—å‡ºç­”æ¡ˆ. 

ä½†æ˜¯è¿™é‡Œæœ‰ä¸€ä¸ªé—®é¢˜, æˆ‘ä»¬çš„ç®—æ³•æ˜¯ä¸æ˜¯æ²¡æœ‰å¤„ç†åˆå§‹æƒ…å†µ? 
\subsection{select çš„ä¸€ä¸ªä¼°è®¡}
å°±æ˜¯è¯´, æˆ‘ä»¬å°†è¿™ä¸ªmembers, ä»€ä¹ˆ members å‘¢? å°±æ˜¯é‚£äº›, å¯èƒ½è¢«ä¸Šé¢ line 6 7 ä¹‹ç±»åˆ æ‰çš„é‚£äº›æ•°å­—. æ’æˆä¸€ä¸ªçŸ©é˜µ, å¦‚æœè¯´ $a _{ij}$ æ¥è¡¨ç¤ºçŸ©é˜µå…ƒç´ . å¹¶ä¸”, æ€»å…±æœ‰ 5 åˆ—. 
æ¯ä¸€åˆ—éƒ½æœ‰ $ n / 5$ ä¸ªå…ƒç´ . å¤§æ¦‚æ˜¯è¿™ä¸ªæ•°å­—, å½“è¿™ä¸ª $n$ å¾ˆå¤§çš„æ—¶å€™, å°±èƒ½å¤Ÿå¿½ç•¥è¿™ä¸ªä½™æ•°å¸¦æ¥çš„å·®åˆ«. 

æ€»ä¹‹è¿™ä¸ªæ—¶å€™æˆ‘ä»¬è¦çœ‹é‚£ä¸ªppt, é‚£ä¸ªppt ä¸Šçš„çº¢è‰²æ ‡è¯†çš„å…ƒç´ , å®é™…ä¸Šå°±æ˜¯, å¾—å‡ºçš„é‚£ä¸ªä¸‹æ ‡çš„å…ƒç´ , é¢å¯¹è¿™äº›ä¸œè¥¿, æˆ‘ä»¬èƒ½å¤Ÿçœ‹å‡º. 
è¿™é‡Œé¢çš„, è™šçº¿æ¡†çš„ä¸œè¥¿, å°±æ˜¯æˆ‘ä»¬å¯èƒ½å‰”é™¤æ‰çš„ä¸œè¥¿, æˆ‘ä»¬å¯¹è¿™ä¸ªæ•°å­—è¿›è¡Œä¸€ä¸ªä¼°è®¡, æˆ‘ä»¬ä¼°è®¡, åˆ æ‰çš„å…ƒç´ å®é™…ä¸Šæœ€å°‘æœ‰ 

\begin{align*}
    \left\lfloor \frac{3n}{10} \right\rfloor
\end{align*}

è¿™æ˜¯å› ä¸º, è¿™ä¸ªæ—¶å€™, å¯¹äºä¸€ä¸ªçŸ©é˜µæˆå‘˜, $a_{\mu \nu}$ , å¦‚æœè¯´ $ \mu \le i , \nu \le j$ æˆ‘ä»¬æ–­è¨€, è¿™ä¸ª $a_{\mu\nu} \le a_{ij}$.
è¿™é‡Œæˆ‘ä»¬è¿›è¡Œäº†ä¸€ä¸ªéå¸¸ç²—ç³™çš„ä¼°è®¡: è¿™é‡Œ, å‡å°‘çš„æˆå‘˜, å¤§æ¦‚æœ‰
\begin{align*}
    \left\lfloor \frac{3n}{10} \right\rfloor
\end{align*}

è¿™æ˜¯ä¸€ä¸ªæ¯”è¾ƒç¼ºå°‘è€ƒè™‘çš„ä¼°è®¡, æˆ‘ä»¬èƒ½å¤Ÿæ˜æ˜¾åœ°ä¸¾å‡ºåä¾‹. ä½†æ€»ä¹‹, è¿™äº›æŠ€æœ¯ç»†èŠ‚, å¹¶ä¸æ˜¯å¾ˆé‡è¦. æˆ‘ä»¬çŸ¥é“ä¸€ä¸ªå¤§æ¦‚å°±è¡Œ: 
\begin{align*}
    n  - \left\lfloor \frac{3n}{10}\right\rfloor \le \frac{7n}{10}   +6 
\end{align*}

å› æ­¤é€’å½’è°ƒç”¨çš„æ“ä½œçš„å¤æ‚åº¦è‡³å¤šæ˜¯ $ T \left( \frac{7n}{ 10} + 6\right)$. äºæ˜¯æˆ‘ä»¬èƒ½å¤Ÿå°±æ­¤å¾—åˆ°é€’å½’æ–¹ç¨‹: 
\begin{align*}
    T \left(n \right) =  
    \begin{cases}
        \Theta \left(1\right) & n \le c \\ \\
        T \displaystyle \left( \left\lfloor  \frac{n}{5} \right\rfloor \right) + T \left( \frac{7n}{10} + 6\right) + \Theta \left(n\right) & \text{otherwise}
    \end{cases}
\end{align*}
äºæ˜¯è¯´, æ—¶é—´å¤æ‚åº¦å°±æ˜¯ 
\begin{align*}
    T \left( n \right) =  O \left( n \right)
\end{align*}
çº¿æ€§æ—¶é—´å†…å°±èƒ½å¤Ÿå®Œæˆ. éå¸¸å¥½ç®—æ³•.

\section{å¤§æ•°ä¹˜æ³•}
åºŸè¯ä¸å¤šè¯´ 

æˆ‘ä»¬è¦åšçš„å°±æ˜¯ä¸¤ä¸ªå¤§æ•°ç›¸ä¹˜, ä½¿ç”¨ç±»ä¼¼çš„æ–¹æ³• (äºŒåˆ†) , è½¬åŒ–ä¸ºå‡ ä¸ªå­é—®é¢˜

ä¸ºäº†æé«˜æ•ˆç‡, è¿™ä¸¤ä¸ªå¤§æ•°æ˜¯ä»¥äºŒè¿›åˆ¶è¡¨è¾¾çš„\footnote{ä¸‹é¢ç”¨åˆ°çš„å·¦ç§»æ“ä½œ, åœ¨è®¡ç®—æœºä¸­åªéœ€è¦å¸¸æ•°æ—¶é—´}
\\ [8pt]
\subsection{é—®é¢˜æè¿°}
\noindent\textbf{Input} : n ä½äºŒè¿›åˆ¶æ•´æ•° $X , Y$ \\
\textbf{Output} : $X, Y$ çš„ä¹˜ç§¯ \\
æˆ‘ä»¬æ­£å¸¸ä¸€ä½ä¸€ä½è®¡ç®—éœ€è¦çš„æ—¶é—´å¤æ‚åº¦æ˜¯ $O\left( n^{2}\right)$\footnote{ä¸ºä»€ä¹ˆæ˜¯
$O$ ç¬¦è™Ÿå‘¢, ä½ çœ‹å¦‚æœè¯´è¿™ä¸ªå¤§æ•°é‡Œæœ‰å¾ˆå¤š $0$, å°±ä¸éœ€è¦ç®—é‚£ä¹ˆå¤šæ¬¡äº†} (ä¸€ä½æ•°ä¹˜ä»¥ $n$
ä½æ•´æ•°æ˜¯ $O \left(n\right)$ çš„æ—¶é—´, $n$ ä½æ•°ä¹˜ä»¥ $n$ ä½æ•°å°±æ˜¯ $O (n \times n  
)$çš„æ—¶é—´), ä½†æ˜¯æˆ‘ä»¬ç”¨ Divide and Conquer 
å¯ä»¥å¾—åˆ°å¤æ‚åº¦ä¸º $O\left( n ^{\log_{2} 3}\right)\approx O\left( n ^{1.59}\right)$ çš„ç®—æ³•.
\subsection{ç®€å•çš„ Divide and Conquer ç®—æ³•}
å°† $X$ è®°ä¸º $A\ |\ B$, å…¶ä¸­ $A, B$ æ˜¯ä¸¤ä¸ª $n / 2$ ä½çš„æ•°å­—, 
$X$ å®é™…ä¸Šç­‰äº $A$ å·¦ç§» åŠ ä¸Š $B$:
\[
X = A \times 2 ^{n /2} + B 
\]
ç±»ä¼¼åœ°, $Y$ è®°ä¸º $C\ | \ D$. äºæ˜¯å°±æœ‰:
\[
\begin{aligned}
XY &= \left(A \times 2^{n /2} + B\right) \times 
\left( C \times 2^{n /2} +D  \right)\\
& = AC \times 2 ^{n} + \left(AD + BC\right) \times 2^{n /2} + BD
\end{aligned}
\]
æ ¹æ®è¿™ä¸ªç­‰å¼æˆ‘ä»¬æœ‰ç¬¬ä¸€ä¸ªç®—æ³•:\\
1. è®¡ç®— $A,B,C,D$\\
2. è®¡ç®— $AC, BD$\\
3. è®¡ç®— $AD + BC$\\
4. $AC$ å·¦ç§», $\left(AD + BC\right)$ å·¦ç§» $n / 2$ ä½\\
5. è®¡ç®— $XY$\\
æ˜¾ç„¶, 1. åªéœ€è¦å¸¸æ•°æ—¶é—´; 2. é€’å½’è°ƒç”¨å‡½æ•° éœ€è¦ $2T(n /2)$ çš„æ—¶é—´; 3. ä¹Ÿæ˜¯é€’å½’è°ƒç”¨, 
åŒæ—¶åŠ æ³•éœ€è¦ $\Theta \left(n\right)$ çš„æ—¶é—´;
4. å·¦ç§», å¸¸æ•°æ—¶é—´;
5. è®¡ç®— $XY$ ä½¿ç”¨åŠ æ³•, $\Theta \left(n\right)$ æ—¶é—´

æ•…
\[
T\left(n\right) = 4 T\left( n / 2\right) + \Theta \left(n\right)
\]
è¿ç”¨Masterå®šç†: $T\left( n\right) = \Theta \left(n ^{2}\right)$

\subsection{æ”¹è¿›çš„Divide and Conquer ç®—æ³•}
æˆ‘ä»¬å¯ä»¥å°†è¿™ä¸ªç­‰å¼ç®€åŒ–ä¸€ä¸‹:
\[
\begin{aligned}
XY &= \left(A \times 2^{n /2} + B\right) \times 
\left( C \times 2^{n /2} +D  \right)\\
& = AC \times 2 ^{n} + {\color{red}\left(AD + BC\right)}\times 2^{n /2} + BD\\
& = AC \times 2 ^{n} + {\color{red} \big(\left(A- B\right) \left(D -C\right)
+AC +BD\big)}  \times 2 ^{ n  /2} +BD
\end{aligned}
\]
åˆ©ç”¨ä¸Šäº†å·²ç»è®¡ç®—äº†çš„ $AC, BD$ æ¥è®¡ç®—ä¸­é—´è¿™å—, æ˜æ˜¾
\[
T\left(n\right) = 3 T\left( n / 2\right) + \Theta \left(n\right)
\]
ç‰¹åˆ«åœ°, å½“ $n=1$ æ—¶, $ T\left(n\right) = \Theta \left(1\right)$. 
ä¸€ç®—å°±æœ‰: $T\left(n\right)= n ^{\log _{2} 3 } \approx n ^{ 1.59}$

\subsection{æ€è€ƒ} èƒ½å¦åˆ©ç”¨è¿™ä¸ªæƒ³æ³•å®ç°çŸ©é˜µä¹˜æ³•é—®é¢˜?

æ„Ÿè§‰å¯ä»¥, ä½†æ˜¯æˆ‘ä¸ä¼š.
\newpage
\section{ç®€å•çš„ChessBoardé—®é¢˜}
\subsection{é—®é¢˜æè¿°}
åœ¨ä¸€ä¸ª $2 ^{k} \times 2 ^{k}$ ä¸ªæ–¹æ ¼ç»„æˆçš„æ£‹ç›˜ä¸­ï¼Œæœ‰ä¸€ä¸ªæ–¹æ ¼ä¸å…¶å®ƒçš„æ–¹æ ¼ä¸åŒï¼Œç§°ä¹‹ä¸ºå¥‡å¼‚å—ã€‚\\
è¦æ±‚ï¼šè‹¥ä½¿ç”¨ä»¥ä¸‹å››ç§Lå‹éª¨ç‰Œè¦†ç›–é™¤è¿™ä¸ªå¥‡å¼‚å—çš„å…¶å®ƒæ–¹æ ¼ï¼Œè¦†ç›–è¿‡ç¨‹ä¸­Lå‹éª¨ç‰Œé—´ä¸èƒ½æœ‰äº’ç›¸è¦†ç›–ï¼Œ
è®¾è®¡ç®—æ³•æ±‚å‡ºè¦†ç›–æ–¹æ¡ˆã€‚å››ä¸ªLå‹éª¨ç‰Œå¦‚ä¸‹å›¾\footnote{ä½ å¯ä»¥çœ‹å‡ºè¿™ä¸ªé—®é¢˜ä¸€ç‚¹ä¹Ÿä¸ä¸€èˆ¬åŒ–}\\
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.3]{6.png}\caption{}
\end{figure}
\subsection{ç®—æ³•è®¾è®¡} 
1. å½“ğ‘˜ > 0æ—¶ï¼Œå°† $2 ^{k} \times 2^{k} $ çš„æ£‹ç›˜åˆ†æˆå››å— $2^{ k-1} \times 2^{k-1}$ çš„å­æ£‹ç›˜

2. ä½¿ç”¨ä¸€ä¸ªåˆé€‚çš„Lå‹éª¨ç‰Œï¼Œè¦†ç›–ä¸‰ä¸ªæ²¡æœ‰ç‰¹æ®Šæ–¹æ ¼çš„å­æ£‹ç›˜çš„ç›¸é‚»æ–¹æ ¼

3. ç»§ç»­é€’å½’å¤„ç†4å­æ£‹ç›˜ï¼Œç›´åˆ°å­æ£‹ç›˜ä¸­åªæœ‰ä¸€ä¸ªç‰¹æ®Šæ–¹æ ¼ä¸ºæ­¢

æˆ‘ä»¬å°†è‡ªå·±å¾—åˆ°çš„ç®—æ³•è®°ä¸º {\sffamily ChessBoard(tr, tc,dr,dc, k)}\\
å…¶ä¸­ {\sffamily tr, tc} æ£‹ç›˜èµ·ç‚¹ (æœ€å·¦ä¸Š) çš„åæ ‡ , {\sffamily dr,dc} æ˜¯ç‰¹æ®Šç‚¹çš„åæ ‡,
{\sffamily k} æ˜¯æ£‹ç›˜ä¹‹å¤§å°. \\
æ€»ä½“æ€è·¯æ˜¯è¿™æ ·\\
1. åˆ’åˆ†æ£‹ç›˜ä¸ºå››ä¸ªè±¡é™\\
2. ç¡®å®šç‰¹æ®Šç‚¹åœ¨é‚£ä¸ªè±¡é™\\
3. å°†ç‰Œæ”¾åœ¨ä¸­å¿ƒ, ä½¿å¾—ç‰Œå’Œç‰¹æ®Šç‚¹æ‰€åœ¨çš„è±¡é™æ— äº¤ç‚¹\\
\begin{figure}[H]
    \centering
    \includegraphics[scale = 0.3]{7.png}\caption{}
\end{figure}
\noindent 4. å°†éª¨ç‰Œçš„å„ä¸ªç‚¹è§†ä¸ºç‰¹æ®Šç‚¹\\
5. å¾—åˆ°äº†å››ä¸ªå­é—®é¢˜, å°†å‚æ•°ä¼ è¿›é€’å½’è°ƒç”¨çš„å‡½æ•°é‡Œ\\
\begin{figure}[H]
    \centering
    \includegraphics*[scale = 0.3]{8.png}\caption{}
\end{figure}
6. OK
\subsection{ç®—æ³•è®¾è®¡çš„ä¼ªç®—æ³•}
\begin{figure}[H]
    \centering
    \includegraphics*[scale = 0.5]{9.png}\footnote{ {\sffamily tile =1//è¢«è¦†ç›–çš„æ–¹æ ¼çš„è®°å· }{\sffamily board[$2^k$][$2^k$]å‚¨å­˜è®°å·ç”¨çš„æ•°ç»„}}\caption{}
\end{figure}
\subsection{å¤æ‚åº¦åˆ†æ}
æˆ‘ä»¬æ ¹æ®ä¸Šé¢çš„ä¼ªä»£ç æ‰¾å‡º recurrence function: 
\begin{align*}
    T \left(k\right) = 
    \begin{cases}
        \Theta \left(1\right)    & k =  0 \\ 
        4 T \left( k- 1\right)  + \Theta \left(1\right) & k > 0\\
    \end{cases}
\end{align*}

then we use some simple techniques to work this out 
\begin{align*}
    T \left(k\right) & =  4 T\left( k -1\right)  + \Theta (1) \\ 
    & = 4 \left( 4 T\left( k -2\right) + \Theta \left(1\right) \right) + \Theta \left(1\right) \\
    & \vdots\\
    & =  4 ^{k } T \left(0\right) + \Theta \left(1\right) \sum_{  i= 0}  ^{k - 1} 4 ^{i}\\
    & = \Theta \left(4 ^{k}\right) 
\end{align*}
\end{document}