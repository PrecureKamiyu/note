
进行加法运算的时候, 就是补码相加. 
 
进行减法运算的时候, 实际上就是 A + (- B) 
 
已知 B, 运算 - B 的补码. 

** 加法的溢出判断
已知, 仅有加法之中, 两者符号相同时, 可能出现溢出.
*** 一位符号位
结果的符号位和加数的符号位不同的时候就出现溢出. 

*** 两位符号位
两位符号位之中, 00 表示正数, 11 表示负数. 

溢出的时候要么 01, 要么为 10. 

两位符号位在乘法之中有应用. 

** 乘法
*** 原码的乘法操作

1. 符号位单独处理
2. 计算 |X| × |Y|

计算后者的时候进行位移和加法操作. 

进行递推算法, 计算 z0 = 0
z1 = (z0 + yn × |x|) >> 1
以此类推! 

1. 使用了绝对值运算
2. 使用位移的次数为结束的判断条件
3. 使用逻辑位移.

能够知道这种乘法操作是能够通过硬件实现的.

*** 补码的乘法操作
什么几把

** Booth 运算法

* 除法
** 笔算除法
算商的过程可以看为比较大小和减法.

** 机器除法
机器除法和乘法相反

设要计算 x / y

符号位单独处理, 随后考虑 |x| / |y|
随后, |x| > |y| 则当前位的商为 1
否则为 0

而后余数左移 1 位.
再求下一位的商.

*** 回复余数法

以恢复的方式进行 x , y 绝对值的大小比较

1. x = x - y
2. if x < 0 then 商为 0 then 恢复余数
   x = x + y
3. if x > 0 then 商为 1

4. 循环节结束, 商和余数左移 1 位.

类似地, 我们通过移位的次数进行判断.
额, 什么时候结束呢?
其说, 对于形为 0.xxxx 的小数, 我们进行四次移位.

额... 我也不懂捏.

*** 加减交替法

Note: 我们只要求掌握原码除法

* 浮点数运算

第一步, 对阶.
比较阶的大小.
阶数小的对齐, 阶码加一, 尾数左移. 也就是右规
直到阶码和大阶数相等. 

第二步, 进行尾数的加法

第三步, 检查溢出
尾数溢出的话, 需要进行右规

需要注意, 我们使用两位符号位, 这个时候需要对算术位移进行细明.

第四步, 舍入


