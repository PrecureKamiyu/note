* 加法
** 加法的基本实现
进行加法运算的时候, 就是补码相加. 
 
进行减法运算的时候, 实际上就是 A + (- B) 
 
*** 取 -B 补码的方法
已知 B, 运算 - B 的补码. 给定了 B 的原码, 连同符号位取反, 再+1 就能够
得到 -B 的补码.
** DONE 存在基本的常识性问题 加法的溢出判断
   CLOSED: [2023-04-16 Sun 16:39]
   - State "DONE"       from "TODO"       [2023-04-16 Sun 16:39]
*** 一位符号位

这个判断并不是很好判断, 我们只考虑进行加法的时候, 明显, 只有当两个加数
的符号相同的时候才有可能出现溢出.

也就是说, 溢出出现, 当且仅当, 加数符号相同, 并且结果的符号和加数的符号
不同. 

*** 两位符号位

两位符号位之中, 00 表示正数, 11 表示负数. 

溢出的时候要么 01, 要么为 10. 前者为两正数相加溢出的情况, 后者为两个负
数相加溢出的情况. 那么, 当

s = 01 | s = 10 

的时候, 发生了溢出. 我们的两位符号位在乘法之中有应用, 只是便宜之合.

* TODO 缺少例子 乘法
*** 笔算乘法

设我们要计算 X × Y, 其中 X, Y 都是小数. 先判断符号, 而后, 将 Y 的每一
位乘以 X, 相加得到结果. 即

z = |X| × y_n >> n + |X| × y_{n-1} >> n-1+ ... + |X| × y_1 >> 1

*** 原码的乘法操作

乘法分为两步走. 

1. 符号位单独处理
2. 计算 |X| × |Y|

设 z = |X| × |Y|, 我们有
z = (|X| × y_n) >> n + (|X| × y_{n-1}) >> n-1+ ... + (|X| × y_1) >> 1

进行递推算法, 使用 z_i 作为中间项. 计算 z0 = 0
z1 = (z0 + y_n × |x|) >> 1
z2 = (z1 + y_{n-1} × |X|) >> 1
以此类推, z1 最终会被位移 n 次, z2 会被位移 n-1 次, 以此类推! 得到 zn
即为结果. 结果还是挺妙的.

总结, 该乘法运算:
1. 使用了绝对值运算
2. 使用位移的次数为结束的判断条件
3. 使用逻辑位移.

并且由于使用了位移, 对于 n 位乘以 m 位的乘法, 我们只需要 max{n , m}的
位长来储存中间的结果. 
在实际之中, 我们会将中间值 z 放在左边, 右边放着除数. 当我们进行 z 的右
移的时候, 自然地, 除数也进行右移; 并且, 除数的位数越来越小, 这就使得,
当我们的除数位数变为 0 的时候, 我们的乘法就结束了. 详情请看 ppt. 对于
下一节和下下节的乘法操作, ppt 上也是同样方法进行处理的.

*** 补码的乘法操作

直观上来看, 因为给定一个补码 y0 y1 y2...yn. 
其真值为

    -y0 + (y1 >> 1) + (y2 >> 2) + ....

其中 (yi >> i) 简记为 [yi].[fn:1]
就有

    X * Y = X * [-y0] + X * [y1] + ... + X * [yn] 

[X × Y] = [X] × Y
而, 就是说, 其结果确实为补码形式, 是需要证明的, ppt 上就有解
释, 虽然跳步严重且不知所云.

*** Booth 运算法

Booth 法用于加速乘法运算. 原理完全类似.

推导过程省去, Booth 算法是用于简化计算的. 类似地, 对于z_{n+1-i} 的计算,
我们看 yi - yi+1. 如果说为 1 那么 zi 要加上 (-x) 后左移, 随后如果说,
其值为 -1 , 那么加上 x 后左移.

|----+------+----|
| yi | yi+1 | R  |
|  1 |    0 | -x |
|  0 |    1 | x  |
|  0 |    0 | 0  |
|  1 |    1 | 0  |
|----+------+----|

于是我们需要 y_{n+1} 的存在, 其值为 0. 

* 除法
** 笔算除法
算商的过程可以看为比较大小和减法.

** 机器除法
机器除法和乘法相反

设要计算 x / y

符号位单独处理, 随后考虑 |x| / |y| 随后, |x| > |y| 则当前位的商为 1 否
则为 0

而后余数左移 1 位. 再求下一位的商.

为了方便起见, 也是为了保证商也是一个小数, 我们最好有 |x| < |y|. 于是结
果也会是一个纯小数, 非常好, 不会引起误会, 于是我们第一步就是多余的了,
因为第一位永远是 0. 当然啦, 符号位之后要加上去的.

*** 回复余数法

符号单独处理, 于是我们只考虑绝对值的除法. 以恢复的方式进行 x , y 绝对
值的大小比较, 我们使用 y* 来当作y 的绝对值. 具体流程为四个步骤.

1. x = x - y
2. if x < 0 then 商为 0 then 恢复余数
   也就是 x = x + y
3. if x > 0 then 商为 1
4. 循环节结束, 商和余数左移 1 位.
   回到步骤1 进行循环. 直到位移次数达到 n 次.

类似地, 我们通过移位的次数进行判断. 求出了四位商的时候应该就
能结束了. 对于 n 位除以 m 位的除法运算, 余数的位数应该为 

max {n, m}

不包含小数点以前的. 我们也能够通过观察余数的位数来判断运算是
否结束.

*** 加减交替法

加减交替法, 实际上完全类似. 

但是我们需要知道 R 是什么. R 就是余数, 或是余数中间数. 我们
递归计算 R. R1 = 被除数 - 除数. 此处分两种情况计算下一个 R, 
也就是 R2

如果说小于零, 那么商 0
R2 = (R1 + 除数) << 2 - 除数 = 2R1 + 除数. 
如果说是大于零, 商 1
R2 = 2R1 - 除数

这就是加减交替法. 非常垃圾. 
Note: 我们只要求掌握原码除法

* 浮点数运算
** 运算流程

第一步, 对阶. 比较阶的大小. 
阶数小的向大的阶数对齐, 阶码加一, 尾数左移.
即右规直到阶码和大阶数相等.

第二步, 进行尾数的加法

第三步, 检查溢出
尾数溢出的话, 需要进行右规

第四步, 舍入

** 具体流程示范

x = 0.1101 x 2 ^{01} 
y =-0.1010 x 2 ^{11}

我们有: 
[x] = 00,01; 00,1101
[y] = 00,11; 11,0110

其中使用两位符号位, 分号前面为阶码, 后面为尾数.
接下来计算 x*y

1. 结束对齐
x 小阶, 需要对齐, 使用右规. 
结果为 
x = 00,11; 00,0011

2. 尾数相加
00,0011 + 11,0110
= 11,1001

结果为 
00,11; 11,1001

3. 
检查
需要进行左规, 因为这是负数, 建议复习一下浮点数的规格化表示.
随后, 结果为

00,10; 11,0010

4. 舍入 
实际上 IEEE 的浮点数舍入要更复杂一些. 只不过这里没有讲. 我们
需要之后的好几位数字来进行舍入的判断. 

Note: 注意到, 我们只知道对于一位符号位的算术位移, 并不清楚两
个符号位的该怎么处理. 
我们将符号位的高位视为, 唯一的符号位对待就行. 比如说, 
10,0000
是一个中间结果, 我们要进行右移, 就有
11,0000

就是说, 如果尾数相加得到了这个结果, 我们进行一点右规, 将其修
正. 

[fn:1] I just don't know why.