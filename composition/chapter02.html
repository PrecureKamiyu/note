<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2023-04-30 Sun 16:01 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>&lrm;</title>
<meta name="generator" content="Org mode" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content">
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf575329">1. chapter 2 ISA and risc-v instruction</a>
<ul>
<li><a href="#orgacba5eb">1.1. ISA 是什么?</a>
<ul>
<li><a href="#org9fa3714">1.1.1. 原则</a></li>
<li><a href="#orgec3be7e">1.1.2. 性能要求</a></li>
</ul>
</li>
<li><a href="#org0648986">1.2. content</a>
<ul>
<li><a href="#org2529588">1.2.1. 存储器寻址</a></li>
<li><a href="#org6bb417c">1.2.2. 对齐问题 <code>[0/1]</code></a></li>
<li><a href="#org839b7c0">1.2.3. c 程序编译为可执行文件的过程</a></li>
<li><a href="#org3acb6c9">1.2.4. 汇编语言的优缺点</a></li>
</ul>
</li>
<li><a href="#orgc1f53c3">1.3. risc-v ISA</a>
<ul>
<li><a href="#org06de167">1.3.1. 指令格式</a></li>
<li><a href="#org0ba08b2">1.3.2. 寄存器</a></li>
<li><a href="#orgda05639">1.3.3. 内存</a></li>
</ul>
</li>
<li><a href="#org7477210">1.4. Instructions introduction</a>
<ul>
<li><a href="#org876a002">1.4.1. primitive instructions</a></li>
<li><a href="#orgf0ef14d">1.4.2. pseudo instruction</a></li>
</ul>
</li>
<li><a href="#org5075811">1.5. How to write a function using assembly <code>[0/3]</code></a>
<ul>
<li><a href="#orgb857d69">1.5.1. How to write a loop</a></li>
<li><a href="#org3f5dcee">1.5.2. the concept of basic block</a></li>
<li><a href="#org9afe75a">1.5.3. Function and stack</a></li>
</ul>
</li>
<li><a href="#orgc25dd41">1.6. The expression of an instruction</a>
<ul>
<li><a href="#org1549b88">1.6.1. the field of an instruction code</a></li>
<li><a href="#org5701489">1.6.2. the type of the instruction code</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#org2949768">2. imm</a></li>
<li><a href="#org42c653e">3. mul</a></li>
<li><a href="#org64b4ee2">4. div</a></li>
<li><a href="#org500462e">5. or and and</a></li>
<li><a href="#org900c1ce">6. shift</a></li>
<li><a href="#org1509bdb">7. save load</a></li>
<li><a href="#orge937b77">8. sign extension</a></li>
<li><a href="#orgfd86d0f">9. add</a></li>
<li><a href="#orge0b8202">10. sub</a></li>
<li><a href="#orge945e27">11. div rem</a></li>
<li><a href="#orgc438fd5">12. xor</a></li>
<li><a href="#orgdaf44f2">13. shift</a></li>
<li><a href="#org1eba2eb">14. shamt</a></li>
<li><a href="#org2670fa7">15. shift left arithmetic</a></li>
<li><a href="#org23b2b1d">16. bne beq blt bltu</a></li>
<li><a href="#org9c4b7a1">17. jalr jal</a></li>
</ul>
</div>
</div>
<div id="outline-container-orgf575329" class="outline-2">
<h2 id="orgf575329"><span class="section-number-2">1</span> chapter 2 ISA and risc-v instruction</h2>
<div class="outline-text-2" id="text-1">
</div>
<div id="outline-container-orgacba5eb" class="outline-3">
<h3 id="orgacba5eb"><span class="section-number-3">1.1</span> ISA 是什么?</h3>
<div class="outline-text-3" id="text-1-1">
<p>
risc-v 是一种指令集架构: ISA (instruction set architecture). 也称为处理器架构
</p>

<p>
使用同一个指令集架构的计算机就是这种 ISA 的系列机, 比如说 risc-v 系列机, Arm 系列机.  
</p>


<p>
一个 ISA 有很多参数, 最基本的参数就是通用寄存器的位宽, 一般有32bit和64
bit之分. 位宽, 指定了通用寄存器的宽度. 其决定了决定了寻址范围的大小, 数
据运算能力的强弱. 地址长度为寄存器的长度, 64 bit 的地址范围当然是比 32
bit 的要长的多. 
</p>

<p>
其需要和指令编码长度分开, 指令的编码长度是越小越好的
</p>
</div>
<div id="outline-container-org9fa3714" class="outline-4">
<h4 id="org9fa3714"><span class="section-number-4">1.1.1</span> 原则</h4>
<div class="outline-text-4" id="text-1-1-1">
<ol class="org-ol">
<li>简单性来自于规则性</li>
<li>越小越快</li>
<li>加速经常性时间.  经常使用的指令尽量短.</li>
<li>需要良好的折衷.</li>
</ol>
</div>
</div>

<div id="outline-container-orgec3be7e" class="outline-4">
<h4 id="orgec3be7e"><span class="section-number-4">1.1.2</span> 性能要求</h4>
<div class="outline-text-4" id="text-1-1-2">
<p>
完备性: 指令丰富, 功能齐全, 使用方便
高效性: 空间小, 速度快
规整性: riscv 比较规整, 但是 x86 相反. 
兼容性: 能够向上兼容
</p>
</div>
</div>
</div>

<div id="outline-container-org0648986" class="outline-3">
<h3 id="org0648986"><span class="section-number-3">1.2</span> content</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>储存器寻址</li>
<li>操作数的类型</li>
<li>控制转移类指令</li>
<li>指令格式</li>
</ul>
</div>

<div id="outline-container-org2529588" class="outline-4">
<h4 id="org2529588"><span class="section-number-4">1.2.1</span> 存储器寻址</h4>
<div class="outline-text-4" id="text-1-2-1">
<p>
大端法和小端法
字地址, 字长度为 32 位 (riscv), 字地址为 addr.
小端法: 将字的低位放在 addr. 次低位放在 addr + 1.
大端法: 将字的高位放在 addr. 
</p>
</div>

<ol class="org-ol">
<li><a id="org5249d7b"></a>寄存器寻址<br />
<div class="outline-text-5" id="text-1-2-1-1">
<p>
直接使用寄存器的名字
</p>

<p>
比如说 x1 就是访问了 x1 寄存器之中的值. 将其用来寻址的话, 就是访问内存
中 x1 为地址的值. 
</p>
</div>
</li>

<li><a id="orgb3ec214"></a>立即数寻址<br />
<div class="outline-text-5" id="text-1-2-1-2">
<p>
真有这东西? 
</p>
</div>
</li>
</ol>
</div>

<div id="outline-container-org6bb417c" class="outline-4">
<h4 id="org6bb417c"><span class="section-number-4">1.2.2</span> 对齐问题 <code>[0/1]</code></h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> 补充该部分</li>
</ul>
</div>
</div>
<div id="outline-container-org839b7c0" class="outline-4">
<h4 id="org839b7c0"><span class="section-number-4">1.2.3</span> c 程序编译为可执行文件的过程</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>编译器 将 .c 文件编译为 .s 文件, 即, 汇编文件</li>
<li>汇编器 将 .s 文件编译为 .o 文件.</li>
<li>链接器 将 library 之中内容连接到 .o 文件里面</li>
<li>加载器 将程序加载到???里面</li>
</ul>
</div>
</div>

<div id="outline-container-org3acb6c9" class="outline-4">
<h4 id="org3acb6c9"><span class="section-number-4">1.2.4</span> 汇编语言的优缺点</h4>
<div class="outline-text-4" id="text-1-2-4">
<p>
废话吧这是
</p>
</div>
</div>
</div>

<div id="outline-container-orgc1f53c3" class="outline-3">
<h3 id="orgc1f53c3"><span class="section-number-3">1.3</span> risc-v ISA</h3>
<div class="outline-text-3" id="text-1-3">
</div>
<div id="outline-container-org06de167" class="outline-4">
<h4 id="org06de167"><span class="section-number-4">1.3.1</span> 指令格式</h4>
<div class="outline-text-4" id="text-1-3-1">
<p>
汇编指令的格式为 
</p>

<p>
op dst, src1, src2
</p>

<p>
这是最一般的指令格式, 其中有 dst(destination), 两个来源 src. 一个指令
对应一个操作. 一行最多一条指令. C语言之中的操作会被分解为一条或者是多
条指令. 来源可以是 imm 也可以是寄存器的值. 
</p>
</div>
</div>

<div id="outline-container-org0ba08b2" class="outline-4">
<h4 id="org0ba08b2"><span class="section-number-4">1.3.2</span> 寄存器</h4>
<div class="outline-text-4" id="text-1-3-2">
<p>
32个通用寄存器, x0&#x2013;x31. 注意这里仅仅涉及 RV32I 或者是 RV64I 的寄存器,
这两个是 risc-v 指令的子集, 其他子集会用到其他的寄存器. 这算 dark side
</p>

<p>
算术逻辑运算所操作的数据必须直接来自于寄存器<sup><a id="fnr.1" class="footref" href="#fn.1">1</a></sup>. 涉及内存的操作只有
load 指令和 save 指令. 其中 x0 是一个特殊的寄存器, 其值恒为 0. RV32I
指令集通用寄存器的长度为 32 位, 而RV64I指令集对应的长度是 64 位
</p>

<p>
汇编是相对原始的, 汇编语言之中没有变量的概念. 直接使用寄存器操作. 直接
使用寄存器能够最大化速度. 缺点在于寄存器的数量非常有限, 需要好好规划. 
</p>


<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">寄存器</th>
<th scope="col" class="org-left">符号</th>
<th scope="col" class="org-left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">x0</td>
<td class="org-left">zero</td>
<td class="org-left">值为0</td>
</tr>

<tr>
<td class="org-left">x1</td>
<td class="org-left">ra</td>
<td class="org-left">return address</td>
</tr>

<tr>
<td class="org-left">x2</td>
<td class="org-left">sp</td>
<td class="org-left">stack pointer</td>
</tr>

<tr>
<td class="org-left">x3</td>
<td class="org-left">gp</td>
<td class="org-left">global pointer</td>
</tr>

<tr>
<td class="org-left">x4</td>
<td class="org-left">tp</td>
<td class="org-left">thread pointer</td>
</tr>

<tr>
<td class="org-left">x5-x7</td>
<td class="org-left">t0-t2</td>
<td class="org-left">temporary register</td>
</tr>

<tr>
<td class="org-left">x8</td>
<td class="org-left">s0/fp</td>
<td class="org-left">save register/frame pointer</td>
</tr>

<tr>
<td class="org-left">x9</td>
<td class="org-left">s1</td>
<td class="org-left">save register</td>
</tr>

<tr>
<td class="org-left">x10-x11</td>
<td class="org-left">a0-a1</td>
<td class="org-left">return value</td>
</tr>

<tr>
<td class="org-left">x12-x17</td>
<td class="org-left">a2-a7</td>
<td class="org-left">function argument</td>
</tr>

<tr>
<td class="org-left">x18-x27</td>
<td class="org-left">s2-s11</td>
<td class="org-left">save register</td>
</tr>

<tr>
<td class="org-left">x28-x31</td>
<td class="org-left">t3-t6</td>
<td class="org-left">temporary register</td>
</tr>
</tbody>
</table>
</div>
</div>

<div id="outline-container-orgda05639" class="outline-4">
<h4 id="orgda05639"><span class="section-number-4">1.3.3</span> 内存</h4>
<div class="outline-text-4" id="text-1-3-3">
<p>
Save Load操作, 实现寄存器和内存之间的读写. 这里我们再次细明一下存储单
元和地址. 
</p>

<p>
一个地址单元是一个 Byte, 一个 Byte 是 8 个 bit. 我们常常用十六进制表示,那
么一个 Byte 可以使用两个字符表示. 比如说 0xFF. 一个 word 表示的是 32
个 bit, 也就是 4 个 Byte. 也有 double word (简写为 dword) 表示的是两个
word, 也就是 8 个 Byte. 还有 half word, 表示的是半个 word, 那就是16个
bit. 这些单位常常以后缀的方式出现在 save load 指令之中. 
</p>
</div>
</div>
</div>


<div id="outline-container-org7477210" class="outline-3">
<h3 id="org7477210"><span class="section-number-3">1.4</span> Instructions introduction</h3>
<div class="outline-text-3" id="text-1-4">
</div>
<div id="outline-container-org876a002" class="outline-4">
<h4 id="org876a002"><span class="section-number-4">1.4.1</span> primitive instructions</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>add 指令</li>
<li>sub 指令</li>
<li>subi 指令</li>
<li>imm 是什么</li>
<li>mul 指令</li>
<li>div 指令</li>
<li>or and 指令</li>
<li>sll sla</li>
<li>save load 指令</li>
<li>shamt</li>
<li>bne beq 指令</li>
<li>jalr jal 指令</li>
</ul>
</div>
</div>

<div id="outline-container-orgf0ef14d" class="outline-4">
<h4 id="orgf0ef14d"><span class="section-number-4">1.4.2</span> pseudo instruction</h4>
<div class="outline-text-4" id="text-1-4-2">
<p>
伪指令有简单理解的, 比如说 mv, sw, lw (sw, lw 本身不是伪指令, 但其有能
够作为伪指令). 也有比较难搞的, 比如说 la li 伪指令.
</p>

<p>
意思是将 \texttt{Label} 所在的指令的地址传输到 \texttt{rd} 上. 其中 \texttt{Label} 表示的是当前 PC 的值和目标指令的差值, 记为 \texttt{delta}, 长度为 32 位. 
</p>
</div>
</div>
</div>

<div id="outline-container-org5075811" class="outline-3">
<h3 id="org5075811"><span class="section-number-3">1.5</span> How to write a function using assembly <code>[0/3]</code></h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li class="off"><code>[&#xa0;]</code> part 1</li>
<li class="off"><code>[&#xa0;]</code> part 2</li>
<li class="off"><code>[&#xa0;]</code> part 3</li>
</ul>
</div>
<div id="outline-container-orgb857d69" class="outline-4">
<h4 id="orgb857d69"><span class="section-number-4">1.5.1</span> How to write a loop</h4>
<div class="outline-text-4" id="text-1-5-1">
<p>
我们需要分支跳转的指令来实现这点, 比如说, 我们要实现一个简单的语句: 
</p>

<p>
for (int i = 0 ; i &lt; 2 ; i++) {
    ans = ans + i;
}                 
</p>

<p>
分析一下就是
</p>
<ol class="org-ol">
<li>写下一个 Label</li>
<li>ans = ans + i;</li>
<li>i++</li>
<li>分支跳转的判断</li>
</ol>

<p>
有: 
    add t0, x0, x0
    add t1, x0, x0
    li  t2, 2
Loop:
    add t1, t1, t0
    addi t0, t0, 1
    bne t0, t2, Loop
</p>

<p>
大概这样, t0 是 i; t1 是 ans; t2 是 2. 当然啦, bne 换为 bge 或许更好.
总是上面就是一个简单的 Loop. 
</p>
</div>
</div>

<div id="outline-container-org3f5dcee" class="outline-4">
<h4 id="org3f5dcee"><span class="section-number-4">1.5.2</span> the concept of basic block</h4>
<div class="outline-text-4" id="text-1-5-2">
<p>
一段经常性执行的代码便是一个 basic block. 由于加速经常性时间的构想, 这
段代码实际上会被特地的优化, 使得其运行速度变得更快. 
</p>
</div>
</div>

<div id="outline-container-org9afe75a" class="outline-4">
<h4 id="org9afe75a"><span class="section-number-4">1.5.3</span> Function and stack</h4>
<div class="outline-text-4" id="text-1-5-3">
<p>
我们有的时候要将数据存入 stack, 而 stack 是位于内存里面的. 我们在手动
进行汇编程序的编写的时候, 要初始化数据, 这个时候我们可以手动地为这些数
据分配空间, 放在 stack 里面. 我们接下来给出一个 bing 的例子:
</p>


<p>
factorial:
    addi sp, sp, -16  # Allocate space on stack
    sw ra, 12(sp)     # Save return address
    sw a0, 8(sp)      # Save argument n
    addi a1, x0, 1    # Initialize result to 1
    beq a0, x0, end   # If n == 0, jump to end
loop:
    mul a1, a1, a0    # result *= n
    addi a0, a0, -1   # n&#x2013;
    bne a0, x0, loop  # If n != 0, jump to loop
end:
    mv a0, a1         # Return result in a0
    lw ra, 12(sp)     # Restore return address
    addi sp, sp, 16   # Deallocate space on stack
    ret               # Return from function
</p>
</div>
</div>
</div>

<div id="outline-container-orgc25dd41" class="outline-3">
<h3 id="orgc25dd41"><span class="section-number-3">1.6</span> The expression of an instruction</h3>
<div class="outline-text-3" id="text-1-6">
</div>
<div id="outline-container-org1549b88" class="outline-4">
<h4 id="org1549b88"><span class="section-number-4">1.6.1</span> the field of an instruction code</h4>
<div class="outline-text-4" id="text-1-6-1">
<p>
一个 instruction code 是32位. 一般来说会划分出大约5到6个field, 这些
field有它们自己的功能. 对于不同类型的指令码, 这些field各有不同. 我们这
里用 add 指令为例子.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">field</th>
<th scope="col" class="org-right">funct7</th>
<th scope="col" class="org-right">rst2</th>
<th scope="col" class="org-right">rst1</th>
<th scope="col" class="org-right">funct3</th>
<th scope="col" class="org-right">rd</th>
<th scope="col" class="org-right">opcode</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">bits</td>
<td class="org-right">7</td>
<td class="org-right">5</td>
<td class="org-right">5</td>
<td class="org-right">3</td>
<td class="org-right">5</td>
<td class="org-right">7</td>
</tr>
</tbody>
</table>

<p>
这是 R-type 指令. 
</p>
</div>
</div>

<div id="outline-container-org5701489" class="outline-4">
<h4 id="org5701489"><span class="section-number-4">1.6.2</span> the type of the instruction code</h4>
<div class="outline-text-4" id="text-1-6-2">
<p>
共有很多类型, 常见的有 R, I, J, S, SB, U 型指令. 
</p>
</div>
</div>
</div>
</div>



<div id="outline-container-org2949768" class="outline-2">
<h2 id="org2949768"><span class="section-number-2">2</span> imm</h2>
<div class="outline-text-2" id="text-2">
<p>
操作名后面加上了一个 i, 那么这个操作是立即数操作. 
其将第二个操作数当作是立即数. 
需要知道的是, 立即数会进行一个符号扩展, 扩展为一个补码表示的.
e.g. \texttt{addi x1, x1, 5}
</p>

<p>
随后, 更值得注意的是, 存在 \texttt{addi}, 但是不存在 \texttt{subi}. 
\texttt{f = g - 10}
实际上是 \texttt{addi x3, x4, -10}
%EndOfParagraph
</p>
</div>
</div>

<div id="outline-container-org42c653e" class="outline-2">
<h2 id="org42c653e"><span class="section-number-2">3</span> mul</h2>
<div class="outline-text-2" id="text-3">
<p>
mulh 取高位指令. 详情请看 ppt 
%EndOfParagraph
</p>
</div>
</div>

<div id="outline-container-org64b4ee2" class="outline-2">
<h2 id="org64b4ee2"><span class="section-number-2">4</span> div</h2>
<div class="outline-text-2" id="text-4">
<p>
详情请看 ppt. 
%EndOfParagraph
</p>
</div>
</div>

<div id="outline-container-org500462e" class="outline-2">
<h2 id="org500462e"><span class="section-number-2">5</span> or and and</h2>
<div class="outline-text-2" id="text-5">
<p>
值得注意的是, risc-v 之中并没有取非操作. 
但是我们可以使用前面的知识, 进行代替. 
</p>
</div>
</div>

<div id="outline-container-org900c1ce" class="outline-2">
<h2 id="org900c1ce"><span class="section-number-2">6</span> shift</h2>
<div class="outline-text-2" id="text-6">
<p>
值得注意的是, 没有算术左移对应的指令
在一定范围内, 也就是算术左移没有发生错误的时候, 算术左移和逻辑左移是等价的. 这一点看以前的记录. 
</p>

<p>
我们复习一下, 什么时候算术位移会发生错误. 我们有这样一个判断标准: 对于左移, 如果左移之后再右移, 不能回到原本的数字的话, 
那么这个左移就出错了. 于是说, 对于左移, 正数丢弃了 \(1\), 或者是负数丢弃了 \(0\), 就会出错.
</p>
</div>
</div>

<div id="outline-container-org1509bdb" class="outline-2">
<h2 id="org1509bdb"><span class="section-number-2">7</span> save load</h2>
<div class="outline-text-2" id="text-7">
<p>
我们可以将寄存器之中东西塞到内存之中. 我们通过内存地址进行内存的访问. 
</p>

<p>
需要注意的是, 其他指令的操作数均是寄存器之中的数, 仅有 \texttt{save load} 指令能够对内存进行操作. 
这是 risc-v 的特点之一. 你可以看出 x86 里面并不是这样的. 格式如下: 
\texttt{memop reg, offset(bAddrReg)}
解释见 ppt. \texttt{memop} 指的是内存相关的操作(也就是 \texttt{s} 或者 \texttt{l}), \texttt{reg} 指的是目标寄存器, 第二个操作数是 
\texttt{offset(bAddrReg)}, 一其中 \texttt{offset} 是一个偏移量; \texttt{bAddrReg} 是寄存器, 将寄存器里的值当作是地址. 整体的地址便是 \texttt{offset + bAddrReg}. \footnote{在 x86 里面, 内存地址的表示更为复杂, 详情请自己找}
</p>

<p>
为传输指令指定大小, 见图~\ref{tab:daxiao}
</p>
\begin{figure}
		\centering
		\begin{tabular}{|c|l|}
		\hline 
		\texttt{sw} &  取字   \\ \hline 
		\texttt{sd} &  取双字 \\ \hline 
		\texttt{sh} &  取半字 \\ \hline 
		\texttt{sb} &  取byte \\ \hline 
		\end{tabular}
		\caption{为命令指定大小}\label{tab:daxiao}
\end{figure}
<p>
%EndOfParagraph 
</p>
</div>
</div>

<div id="outline-container-orge937b77" class="outline-2">
<h2 id="orge937b77"><span class="section-number-2">8</span> sign extension</h2>
<div class="outline-text-2" id="text-8">
<p>
我们进行 \texttt{load} 命令的时候, 要指定大小, 比如说 \texttt{w}, \texttt{d}, \texttt{h}, \texttt{b}.
这就是说, 我们要将一个长度为 \(32/64/16/8\) 的数据, 送到 \(32\) 或者是 \(64\) 位的寄存器里面. 这个时候, 
计算机会对传输的数据进行 \textbf{符号扩展}. 也就是将这一小串数据, 看作是补码, 然后扩展为 \(32\) 或者\(64\)位的补码. 
</p>

<p>
比如说一个传入了一个字节 \texttt{0x80}, 写为二进制为 \texttt{10000000}. 也就是有符号位 \(1\), 是一个负数, 于是扩展为 \(32\) 位的补码的时候就变为 \texttt{0xFF80}.
</p>

<p>
值得注意的是, 默认读数据的时候, 写入的时候, 会将数据扩展, 看作是有符号的
若是需要写入无符号数的话, 需要加上 \texttt{u}. 
</p>

<p>
e.g. 传输数据的举例. 见 ppt 实际上不是很难. 
</p>

<p>
\paragraph{涉及掩码的数据传输}
</p>
</div>
</div>

<div id="outline-container-orgfd86d0f" class="outline-2">
<h2 id="orgfd86d0f"><span class="section-number-2">9</span> add</h2>
<div class="outline-text-2" id="text-9">
<p>
add 指令的表示为 
add rd, rst1, rst2
</p>

<p>
rd is register of destination
</p>

<p>
The command tell computer to do the computation---\texttt{rd = rst1 + rst2}. Note that rst1 rst2 are treated as signed number. 
</p>


<p>
Additionally, \texttt{addi} tells computer to do \texttt{rd = rst1 + imm}, where \texttt{rst2} is replaced by an immediate number.
</p>
</div>
</div>

<div id="outline-container-orge0b8202" class="outline-2">
<h2 id="orge0b8202"><span class="section-number-2">10</span> sub</h2>
<div class="outline-text-2" id="text-10">
<p>
\centerline{\texttt{sub, rd, rst1, rst2}}
is the form of the instruction, telling that \texttt{rd = rst1 - rst2}. 
</p>

<p>
It is worth noting that there is no such thing as \texttt{subi}, cause \texttt{addi} can do the same thing.
\subsubsection{mul}
</p>
</div>
</div>
<div id="outline-container-orge945e27" class="outline-2">
<h2 id="orge945e27"><span class="section-number-2">11</span> div rem</h2>
</div>
<div id="outline-container-orgc438fd5" class="outline-2">
<h2 id="orgc438fd5"><span class="section-number-2">12</span> xor</h2>
<div class="outline-text-2" id="text-12">
<p>
Logical operations can do thing likes 掩码. To achieve this we can use \texttt{and} and \texttt{0xFFFFFFFF}. Let us assume that the length of register is 32. A number \texttt{and} \texttt{0xFFFFFFFF} is the number itself. But when it \texttt{and} \texttt{0x0FFFFFFF}, the number loose it first four bits.
</p>
</div>
</div>

<div id="outline-container-orgdaf44f2" class="outline-2">
<h2 id="orgdaf44f2"><span class="section-number-2">13</span> shift</h2>
<div class="outline-text-2" id="text-13">
<p>
\centerline{\texttt{s + l/r + a/l + [i]}}
is the decompostion of an instruction,
where \texttt{s} for shift, \texttt{l,r} for \textbf{left} or \textbf{right}, \texttt{a,l} for \textbf{arithmetic} or \textbf{logical}. \texttt{[i]} is optional, which stands for \texttt{imm}.
</p>

<p>
About the arithmetic shift, you check 01.pdf out.
</p>
</div>
</div>

<div id="outline-container-org1eba2eb" class="outline-2">
<h2 id="org1eba2eb"><span class="section-number-2">14</span> shamt</h2>
<div class="outline-text-2" id="text-14">
<p>
Indeed, for a 64-bits data store in a register. It would be of no use to shift of 64-bits, which resulting that in \texttt{slai} or other shifting command ending with \texttt{i}, only the lowest 6-bits of immediate number are useful. Other bits are abandoned. The remaining part is called shamt. 
</p>
</div>
</div>

<div id="outline-container-org2670fa7" class="outline-2">
<h2 id="org2670fa7"><span class="section-number-2">15</span> shift left arithmetic</h2>
<div class="outline-text-2" id="text-15">
<p>
There is not such thing as \texttt{sla[i]}. We already know when the shift cause ailment. Exactly when the number is starting with \texttt{10} or \texttt{01} the result of \texttt{sla} is not what we want. 
</p>

<p>
However, you may check that when there is no ailment, \texttt{sla} works just like \texttt{sll}. So \texttt{sla} become less needed. 
\subsubsection{s, l}
\centerline{\texttt{s/l r, offset(AddR)}}
where \texttt{AddR} is a register. The command tells computer to load data from address \texttt{offset + AddR} to \texttt{r}, or to save the data in \texttt{r} to address \texttt{offset + AddR}.
\subsubsection{address and word and byte}
A \textbf{word} in risc-v has \textbf{32} bits. There arouses an interesting question: how to load 32-bit data to a 64-bit register? 
</p>

<p>
No, what I am saying is that you need to care for whether the data is unsigned type or not. You need to expand a number when it is treated as a negative number. 
\subsubsection{slt}
slt for set less than. \texttt{slt} is an instruction to compare the value of some data. 
</p>

<p>
\centerline{\texttt{slt rd, rst1, rst2}} 
means that \texttt{rd = rst1 and rst2}
</p>
</div>
</div>


<div id="outline-container-org23b2b1d" class="outline-2">
<h2 id="org23b2b1d"><span class="section-number-2">16</span> bne beq blt bltu</h2>
<div class="outline-text-2" id="text-16">
\begin{enumerate}
\item b for break
\item eq for equal.
\item ne for not equal. 
\item lt for less then.
\item ge for greater or equal.
\end{enumerate}
<p>
Use this set of command to jump which is used to achieve if-else structure. Note that for blt and bge, there exists unsigned type of commands. 
</p>
</div>
</div>

<div id="outline-container-org9c4b7a1" class="outline-2">
<h2 id="org9c4b7a1"><span class="section-number-2">17</span> jalr jal</h2>
<div class="outline-text-2" id="text-17">
<p>
\centerline{jal rd, Label}
称为无条件跳转. PC+4 存贮在 rd 之中. 并且 PC 赋值为 \texttt{Label}. 
</p>

<p>
\texttt{Label} 是一个写在程序行首的标签, 比如说 \texttt{Exit} 或者 \texttt{Loop} 等. 程序运行的时候此标签会翻译为一个指令的地址. 
</p>

<p>
The actual operation it takes is PC = PC + \texttt{offSet}, where \texttt{offSet} is translated from \texttt{Label}. 
</p>

<p>
\centerline{jalr rd, offSet(AddR)}
是 \texttt{jalr} 的格式. 其表示, \texttt{rd} = PC + 4. 将 PC 的值赋为 \texttt{offset + AddR}. 
</p>
</div>
</div>
<div id="footnotes">
<h2 class="footnotes">Footnotes: </h2>
<div id="text-footnotes">

<div class="footdef"><sup><a id="fn.1" class="footnum" href="#fnr.1">1</a></sup> <div class="footpara"><p class="footpara">
在 x86 之中并非如此, 大部分指令都可以对内存之中的数据进行操作.
比如说我们有一个 add 指令. 写为 
</p>

<p class="footpara">
add x1, x1, Imm(x2)
</p>

<p class="footpara">
(当然了, x1 并不是 x86 之中寄存器的名字)这是说, 我们找到 Imm + x2 为地
址的内存数据, 加上 x1 之后再加到 x1 上.
</p></div></div>


</div>
</div></div>
<div id="postamble" class="status">
<p class="date">Created: 2023-04-30 Sun 16:01</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>