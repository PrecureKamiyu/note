\documentclass[a4paper, 12pt]{ctexbook} %中文支持
\usepackage{float}              %防止浮动元素浮动
\usepackage{rotating}           %旋转图片
\usepackage{amsfonts}           %对某一些字体之支持
\usepackage{amsmath}            %数学公式
\usepackage{amssymb}            %用来加入一些数学符号, 比如说 $\varnothing$
\usepackage{amsthm}             %定义, 定理, 证明, 例子环境的支持
\usepackage{graphicx}           %插入图片
\usepackage[left=1.5in,right=1.5in,top=1in,bottom=1in]{geometry}   %用来排版的
\usepackage{color}              %给部分文本上色的
\usepackage{algorithm}          %写伪代码的
\usepackage{algorithmic}        %同上
%\usepackage{minted}             %书写代码
\usepackage{fontspec}           %不知道用来干嘛的
\usepackage{titlesec}           %用来调整section等的大小和字体
\usepackage{hyperref}           %生成可跳转的书签
\usepackage{blindtext}          %for test

\pagestyle{plain}               %这是调整页面的风格, plain的情况下只有页码

%titlesec
\titleformat*{\section}{\huge\bfseries}             %管理title的字体和大小
\titleformat*{\subsection}{\Large\bfseries}         %bfseries就是默认的字体.
\titleformat*{\subsubsection}{\large\bfseries}      

%\setmonofont{vs}                %调整这个minted代码的风格
\theoremstyle{plain}
\newtheorem*{comment}{Comment}

\theoremstyle{definition}
\newtheorem{theorem}{\llap{$\rhd$}\space Theorem}
\newtheorem{example}{\llap{$\bigstar$}\space Example}
\newtheorem{definition}{\llap{Definition}\space}[section]
\newtheorem{lemma}{\llap{Lemma}\space}
\newtheorem{proposition}{\llap{Proposition}\space}

\theoremstyle{remark}
\newtheorem{remark}{\llap{Remark}\space}

% 以上是导言区

% TODO: 
% 1. section 引入需要补充.
% 2. 自由变元和约束变元, 写到这里了.
\begin{document}
\tableofcontents
\chapter{一阶逻辑的语言}
\section{引入}
与其说是引入, 不如说是一个介绍, 这里我们介绍的便是一阶逻辑
的语言. 什么是语言, 就是说, 在我们讲述一阶逻辑的
定义和性质的之前, 我们先是要介绍1. 一阶逻辑的定义; 2. 一阶逻辑的记号. 

\section{一阶逻辑的语言的定义}
\begin{definition}
语言 $L$, 包括了:
\begin{enumerate}
    \item 括号: nothing special. 
    \item 联结词: $\left\{\neg , \rightarrow\right\}$, 也是常规, 就如同我们之前所用到的. 
    \item 量词: $\forall $, 一阶逻辑之中一个比较重要东西, 说的那么模糊是因为我也不懂. 
    \item 变元: $v_{1}, \cdots $, 不知道, 相当于变量 $x$ ? 
    \item 常数: 和变元相对应的概念. 
    \item 函数: 可以理解为比函数更为抽象的一个概念. 
    \item 谓词: 可以理解 be , `是', 当然目前我是这么理解的. 
    \item 等词: $\approx$, 也是一个谓词, 但是地位非常特殊.
\end{enumerate}
\end{definition}
\begin{example}
\begin{enumerate}
    \item 集合论的\textbf{语言}是集合 $\mathcal L _{Set} = \left\{\in , \approx\right\}$. 其中, $\in$ 是一个
    二元谓词. 比如说 $a \in A$ , $\in$ 有两个entry, 所以说是二元的. 
    \item 初等数论的\textbf{语言}是集合 $L = \left\{< , 0 , S , + , \cdot , \approx\right\}$. 
    $S$ 的意思是后继, 是一个一元函数, $+, \cdot$ 均是二元函数. $0$ 是一个常元.
    \item 序关系的\textbf{语言}是 $L  = \left\{R\right\}$. 
\end{enumerate}
\end{example}
啊, 我们从这些例子之中, 是否就能够稍微地感受出, 什么是谓词以及什么是函数了. 
\begin{definition}[项]
设 $L$ 是一个一阶语言. $L$ 之中的项 (term) 是如下递归地定义的. 
\begin{enumerate}
    \item 变元都是项; 
    \item 常数都是项;
    \item 如果说 $t_1 , t_2 ,\cdots , t_{n}$ 是项, $f$ 是一个 $n$ 元函数, 那么 $f \left( t_{1} , t_{2} , \cdots  , t_{n}\right)$ 也是项. 
\end{enumerate}
\end{definition}
\begin{remark}
$f\left(t_{1},  \cdots  , t_{n} \right)$ 也可以写为 $f t _{1} \cdots t_{n}$, 我看不出有什么区别. 后者难看一点. 
\end{remark}
\begin{example}
$S 0, + v_{1} SSS 0 $ 和 $\times S 0 + 0 S SS 0 $ 是项. 当然, 我们可以将 $ + t_{1} t_{2} $ 写为 
$t _{1}  + t_{2} $, 不会有什么歧义. 

$S 0 $ 就是 $0$ 的后继, viz. $1$. 

$+ v_{1} SSS 0 $ viz. 变量 $v_{1}$ 加上 $3$.

$\times S 0 + 0 SSS 0 $ viz. $\left( 0 + 3\right) \times 1$
\end{example}
接下来我们开始定义命题, 或者说公式, 或者说合式公式, 或者说 Proposition.
\begin{definition}
$L$ 是一个一阶语言. 其中的 Proposition 定义为: 
\begin{enumerate}
    \item 如果说 $t_{1} , t_{2} , \cdots  , t_{n}$ 是项, $P$ 是一个 $n$ 元谓词, 
    那么 $P \left( t_{1} , t_{2} , \cdots, t_{n} \right)$ 是一个 Proposition.
    \item 如果说 $\alpha , \beta$ 是命题, 那么 $ \left( \neg \alpha \right) , \left( \alpha \to \beta \right)$ 也是公式. 
    \item 如果说 $\alpha $ 是公式, 那么 $ \forall  v_{i} \alpha$. 
\end{enumerate}
\end{definition}
\begin{remark}
其中 $P\left( t_{1} , \cdots  , t_{n}\right)$ 称为原子公式. 
并且, $\forall $ 目前只是一个符号, 现在不能对其做一个含义上的推断. 
$\forall v_{i} \alpha$ 并不能理解为 `对于全部的 $v$\dots' 什么的. 
\end{remark}
\begin{remark}
\begin{enumerate}
    \item 我们使用 $\exists x \alpha $ 作为 $\neg \left( \forall  x \left( \neg \alpha\right)\right)$ 的简写. 称 $\exists$ 为存在量词. 
    \item 我们使用 (不约等于) 来表示 $\neg \left( \alpha \approx \beta\right)$
    \item 我们通常使用 $P, Q,  R$ 来表示谓词; 使用 $x,  y , z $ 或者 $v$ 来表示变量; 使用 $f , g , h$ 来表示函数; 
    使用 $a ,  b  , c$ 来表示常数; 使用 $\alpha , \beta , \varphi, \sigma , \tau$ 来表示公式; $t$ 来表示项; $\Gamma , \Delta , \Sigma$ 来表示公式集合. 
\end{enumerate}
\end{remark}

\subsection{一阶语言的例子}
例子有很多, 比如我们在学习那个集合论与图论的时候涉及到了一些一阶语言的表述. 
所以说是非常脑瘫, 这你吗, 应该先学这个啊! 另外一个例子便是大名鼎鼎的卓里奇的
数学分析, 其中运用了大量的一阶逻辑语言来简化表述. 好像没有我想得那么多, 但还是有. 

\paragraph{哲学语言} % (fold)
\label{par:哲学语言}
由于分析哲学的原因, 虽然我也不知道是什么原因, 但总之确实是这个原因, 
很多哲学家喜欢使用一阶语言来重述一些命题. 总之我们来看 
\begin{example}
    当今的法国国王是一个秃子.
    \[
    \forall  x \left(P _{1} ^{1} \left(x\right) \to P_{2} ^{1} \left(x\right)\right)
    \]
    其中, $P$ 的下标代表的这是第几个谓词, 而上标代表这是几元谓词. 
\end{example}
\begin{example}
    金山不存在. 
    \[
    \neg \exists x \left( P ^{1} _{3} \left( x\right) \wedge P _{4} ^{1} \left( x\right) \right)
    \]
\end{example}
% paragraph哲学语言 (end)

\paragraph{算术语言} % (fold) 
\label{par:算术语言}
$L  =\left\{ \approx , < , 0  , S , + , \cdot\right\}$
\begin{example}
    $0$ 不是任何自然数的后继
    \[
    \forall  x \left( \neg \left( S x \approx 0\right)\right)
    \]
    或者说
    \[
    \neg x \left( S x \approx 0\right)
    \]
\end{example}
差不多得了, 稍微体验一下就行了. 
% paragraph算术语言 (end)

\paragraph{群的语言} % (fold)
\label{par:群的语言}
$L = \left\{e ,  + \right\}$
\begin{example}
    群加法满足结合律
    \[
    \forall  a 
    \]
\end{example}
% paragraph群的语言 (end)
\section{量词的辖域 (the scope of quantifiers)}
这是个棘手的问题, 比如说下面这个: 
\begin{example}
Senario: $ \left(\forall   y H \left( y\right) \to \exists z W \left(z,  y\right) \right) \to \exists z G \left(z\right)$

Question: $\exists z W \left(z,  y\right)$中的 $y$ 是否是包含于 $\forall y$ 的辖域之中呢? 
\end{example}
辖域就是这个量词`管辖'的范围, 在辖域之中的变量被这个量词限制的. 
\subsection{定义}
我们还需要一个正经的定义, 我们给出两种定义: 
\begin{definition}
$L$ 是一个一阶语言, $A$ 是 $L$ 中的公式, 设 $Q$ 是量词的在 $A$ 之中的一个occurence, 设其后面接着的变量是 $v$. 

$B$ 是 $Q$ 的辖域, 如果 $B$ 以 $Qv$ 开头, 且其任意的真截断不是公式. 

其中 $B$ 的截断 $w$ 满足 $B = w w'$ ($B$ 毕竟是一个字符串), 当 $w' \ne \epsilon$ 的时候, $w$ 称为 $B$ 的真截断, 即, 真截断 $w$ 满足 $w  \ne B$
\end{definition}
\begin{comment}
$\epsilon$ 是空字符串. 这里还是建议不要遗忘这点. 
\end{comment}

其实还有等价的定义, $B$ 是以 $Q v$ 开头的, 最大的一个, 公式的子字符串.  接下来给出第二种定义: 
\begin{definition}
$A$ is a well-formed formula in $L$, and $Q$ is an occurrence of a quantifier in $A$. 

Let $B$ be a well-formed part of $A$ such that $B$ begins with $Qx$.

$B$ is called the scope of the quantifier $Q$. 
\end{definition}
这里涉及到了非常多的概念, well-formed formula, occurrence, well-formed part. 这些定义还涉及到了 collations 什么的东西. 总之, 啊, 前者比较好理解吧, 毕竟是中文写的. 

但是我们这里进行另一个表述, 这个表述要简单得多, 
我们只需要记住, 量词 $Q$ 的辖域是紧接其后的一个原子公式. 

\begin{definition}
$A$ is a formula in $L$, $Q$ is an occurrence of a quantifier in $A$, 
let $B$ be an atomic formula right after $Q x$, then $B$ is the scope of $Q$.
\end{definition}
\subsection{Binding a variable over multiple quantifiers}
如题, 在同一个变量上面作用了多个量词, 这个时候该怎么进行分析? 
\begin{example}
我们来看这个: 
\[
\exists x \forall  x P \left(x\right)
\]
\end{example}
我甚至读不懂这个东西! 我们根据网络上搜索到的资料来解答. 
\subsubsection{问题 1} 
这里是问题来源\footnote{https://math.stackexchange.com/questions/3535109/binding-a-variable-over-multiple-quantifiers}. 
面对上面 Example 4 的时候, 即面对
\[
\exists x \forall  x P\left(x\right)
\]
的时候, 我们宣称, 最里面的那个量词才是真正限制变量的那个量词. 
这里的话便是 $\forall $ 限制了 $x$. 就是说, 
\[
\exists x \forall  x P \left(x\right) \equiv  \exists x \forall  y P\left(y\right) \equiv  
\forall  y P\left(y\right) \equiv  \forall  x P\left(x\right)
\]
最外圈那一层的量词, viz. $\exists$ 跟没有一样. 这个问题就和我们程序之中变量名称和类似, 
甚至scope这个用语都是通用的. 

一个回答进一步宣称, $\exists x \forall  x P\left(x\right)$ 甚至不是一个well formed formula, 这样的话直接避免处理这种东西, 直接将其视为非法的. 虽然说 $\exists x \forall  x P \left(x\right) $ 其实是 WFF, 他这个说法其实并不是很能站得住脚, 但是也未必没有参考价值. 

\subsubsection{问题 2}
这里是问题来源\footnote{https://math.stackexchange.com/questions/1100506/more-than-one-quantifiers-for-one-variable-forall-x-exists-x-px}. 
I can't read this: $\forall  x \exists x P \left(x\right) $. Help me. 

这个公式是well formed的, 只不过是有点反人类. 当然最好的方式就是避免对同一个变量使用嵌套的量词,
我们应该做的, 就是稍微更改一下使用的变量名称, 使得其更为清晰. 
重点便是搞清楚一个量词的辖域, 量词是不能干涉到辖域之中的, 同一个变量名称的辖域的. 

以 $\forall  x \exists x P \left(x\right) $ 为例, 
$\forall  x  $ 的辖域是 $\forall  x \left(\exists x P \left(x\right)\right)$, 
这个辖域之中还有另一个辖域, 并且还是同一个变量, viz. $\exists x P\left(x\right)$, 那么外边 $\forall $ 就不能限制 $\exists x P \left(x\right)$ 之中的 $x$. 
\[
\forall  x \left(\exists x P \left(x\right) \right) \equiv  \forall  x \left(\exists y P \left(y\right)\right) \equiv  \exists y P \left( y\right)
\]
进一步, 我们给出一个更为清晰的例子. 
\[
\forall  x \ \Big( Q \left(x \right)  \wedge \exists x \left( P \left(x \right) \vee R \left(x\right)\right)\Big) 
\]
$\exists x  $ 的辖域是 $ \exists x  \left(P \left(x\right) \vee R \left(x\right)\right)$, 这个公式和下面这个是等价的, 
\[
\forall  x \ \Big(Q \left(x\right) \wedge \exists y \left( P \left(y\right) \vee R \left(  y \right)\right)\Big)
\]
$\forall  x  $ 管到了 $Q \left(x\right) $ 却没有管辖 $\exists x$ 内部的东西. 

\section{自由变元和约束变元}
\end{document}