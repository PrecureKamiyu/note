\documentclass[12pt]{ctexart}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{graphicx}
\usepackage{hyperref}
\pagestyle{plain}

\theoremstyle{definition}
\newtheorem{theorem}{Def}[section]
\newtheorem{lemma}[theorem]{Lemma}
\theoremstyle{definition}
\newtheorem{definition}{定义}[section]
\newtheorem{thm}[definition]{定理}

\theoremstyle{plain} 
\newtheorem{exam}[definition]{Example}

\begin{document}
\tableofcontents
\section{DFA 和 NFA}
\subsection{NFA}
\subsubsection{NFA 的性质}

NFA, 可以允许多个现态, 以及一个现态可以有多个次态. 仅仅是状态转移函数的定义有着不同. 其定义如下: 
\begin{equation}
\delta \colon Q \times \Sigma \to 2 ^{Q}
\end{equation}
而 DFA 的状态转移函数长这个样子: 
\begin{equation}
\delta \colon Q \times \Sigma \to Q 
\end{equation}

\begin{exam}
检测末尾为01的只由0和1组成的序列的 NFA. 状态转移函数如下\footnote{图就不画了, 真不会画}: 
\begin{figure}[h]
\centering
\begin{tabular}{|r|cc|}
\hline
& \(0\) & \(1\) \\ 
\hline 
$\to$ \(q_{0}\) & \(\{ q_{0}, q_{1}\}\) & \(\{q_{0}\}\)\\ 
\(q_{1	}\) & $\varnothing$ & \(\{q_{1} \}\) \\
\(^{*}q_{2}\) & $\varnothing$ & $\varnothing$\\
\hline
\end{tabular}
\end{figure}

\end{exam}
\begin{definition}[状态转移函数的拓展]
\(\delta\) 可以扩展为 \(\hat{\delta}\colon Q \times \Sigma ^{*} \to 2^{Q}\), 定义是递归的, 如下:
\[
\hat{\delta}(q, w) = 
\begin{cases}
q &, \text{if } w = \epsilon \\
\bigcup_{p\in \hat{\delta}(q,x)} \delta(p,a) & , \text{if } w = xa
\end{cases}
\]
这个函数告诉了我们, 给定初态 \(q_{0}\), 以及一个输入的字符串 \(w\)之后我们的现状 (集合) 是什么. 
\end{definition}
\begin{thm}[NFA和DFA之间的等价性]\label{Thm:nfa=dfa}
一个语言 \(L\) 能被 NFA 接收, 当且仅当能被 DFA 接收
\end{thm}
\begin{proof}
我们需要证明的是: 给定一个 \(N\), 存在一个 \(D\) 使得 \(L (N) = L (D) \), 以及反过来的版本, 给定一个 \(D\) 存在一个 \(N\) 使得 \(L (D) = L(N)\).
注意到 DFA 是一个 NFA 的一个特例, 于是我们能够知道: \(\forall D \exists N (L(D) = L(N)) \). 于是我们要证明的便是, 如果 \(L\) 能够被 NFA 接收, 那么 \(L\) 能够被 DFA 接收. 

使用构造法. 给定一个 NFA , 能够构造出一个 DFA 接收 \(L\). 这里使用的构造法称为子集构造法. 原理很简单: 对于一个 NFA, 其 `现态集合' 虽然是一个集合, 但是可以视为一个 DFA 的现态. 因为状态是有限的, 所以说, 状态集合的幂集也是有限的, 若是能够将 NFA 看作是一个 DFA , 那么其现态就是一个 \(\Sigma\) 的子集, 当然次态也是一个 \(\Sigma\) 的子集. 

我们给定 NFA \((Q,\Sigma,\delta, q_{0},F)\), 构造 DFA \((Q' , \Sigma, \delta ' , \{q_{0}\}, F')\), 其中 
\[
\begin{aligned}
& Q '  =  2 ^{\Sigma} \\ 
& F' = \{ S \mid S \in Q ', S \cap F  \ne \varnothing \}
\end{aligned}
\]
注意到, \(\{q_{0}\}\in Q'\), 这是我们加上 \(\{\}\) 的原因. 其中 \(\delta '\) 的定义如下: 
\[
\delta ' (S, a) = \bigcup_{q_{i} \in S} \delta (q_{i}, a) 
\]
我们需要证明 \(\forall s \in \Sigma ^{*} (\hat{\delta'} (q_{0}, s) = \hat{\delta} (q_{0},s))\). 证明等会在说. 
\end{proof}

\begin{thm}
\( \hat{\delta}(q_{0},s) = \hat{\delta'}(q_{0}, s)\)
\end{thm}
\begin{proof}
对字符串的长度进行归纳:
当长度为 \(n=0\)
\begin{equation}
\hat{\delta'} (\{q_{0}\}, \epsilon ) = \{q_{0} \}  = \hat{\delta} (q_{0}, \epsilon) 
\end{equation}

当长度为 \(n = k\), 设假设成立.

当长度为 \(n  = k  + 1\), 设 \(w = x a \), 那么 \( \hat{\delta} (q_{0}, w ) = \bigcup_{p \in \hat{\delta} (q_{0}, x) } \delta (p, a)\). 
而 \( \hat{\delta'} (q_{0}, w) = \delta'  (\delta' (q_{0}, x), a)\). 后者的定义为 \(\bigcup_{p \in \hat{\delta'}(q_{0}, x)} \delta(p, a)\). 
因为 \(x\) 的长度为 \(k\), 所以 \( \hat{\delta' } (q_{0}, x) = \hat{\delta} (q_{0}, x)\), 因此 \( \hat{\delta ' } (q_{0}, w) = \hat{\delta} (q_{0}, w) \) 恒成立. 
\begin{equation}
\delta ' (\delta' (q_{0}, x)) = \bigcup_{p \in \hat{\delta'} (q_{0}, x )} 
\delta (p, a ) = \bigcup_{p \in \hat{\delta} (q _{0}, x) } \delta (p, a ) = \hat{\delta} (q_{0}, w) 
\end{equation}
\end{proof}
我们知道了 \( \hat{\delta} (q_{0}, w )  = \hat{\delta ' } (q_{0}, w )\) 之后, 就能够证明 \(L (N) = L(D)\) 了. 只需要注意到 \(L (N)\) 的定义: 对于任意的 \(s \in L (N)\), 都有 \( \hat{\delta' } (q_{0}, s) \cap F \ne \varnothing \). 我们知晓了这个定义之后就能够证明 \(L (N) = L (D)\) 了, 这是显然的. 

\subsubsection{NFA 转化为 DFA 的方法}
使用上面的子集构造法就能够进行转化, 随后我们将不需要的状态进行删除即可. 
\subsection{带空转移的 NFA}
空转移的意思便是, 在没有输入的时候状态可以自己发生转移, 这样的自动机记为 \(\epsilon\)-NFA, 其中 \(\epsilon\) 是空字符串的意思. 在本小节之后, 如果没有特别说明, NFA 包括 \(\epsilon\) - NFA 和 NFA. 
\subsubsection{\(\epsilon-\text{NFA}\) 的定义}
仅有一处和 NFA 不同, 状态转移函数的定义不同: 
\begin{equation}
\delta \colon Q \times (\Sigma \cup \epsilon ) \to 2 ^{Q}
\end{equation}
并且, 我们需要理解什么是 \(\epsilon\): 对于一个输入的字符串 \(s\), 其等价于 \(s\epsilon\), 也等价于 \(s\epsilon\epsilon\). 当然, \(\epsilon\) 插在中间也是可以的.

\begin{exam}
% TODO ! 
\end{exam}

\begin{definition}[\(\epsilon\) closure]
给定一个状态集合 \(S\), 那么 \(S\) 的 \(\epsilon\) closure 为 \(S\) 并上那些当前状态通过空转能够达到的状态, 记为 \(\bar{\epsilon} (S)\). 记 \(\bigcup_{s \in S} \delta (s , \epsilon ) \) 为 \(\epsilon _{1} (S)\), 并且记 \(\bigcup_{s \in \epsilon _{1} (S)} \delta (s, \epsilon )\) 为 \(\epsilon _{2} (S) \), 那么就能够得到 \(\overline{\epsilon} (S)\) 的表达式: 
\begin{equation}
\bar\epsilon (S) = S \cup \epsilon_{1} (S) \cup \epsilon_{2	} (S) \cup \cdots
\end{equation}
当然可以写为 
\begin{equation}
\overline{\epsilon} (S)  = \big(\bigcup_{n = 1} ^{ \infty}\epsilon_{n} (S) \big) \cup S
\end{equation}
特别地, 可以称呼 \(S\) 为 \(\epsilon_{0} (S)\). 表达式还可以再精简一点. 
\end{definition}

引入 \(\epsilon\) closure 的概念是为了定义 \(\hat{\delta}\), 以及下文之中 \(\epsilon\) -NFA 向 DFA 转换. 
\begin{definition}[\(\delta\) 函数的扩展]
同样地, \(\delta'\) 的定义也是递归的. 定义如下: 
\begin{equation}
\delta' (q_{0}, w) = 
\begin{cases}
\overline{\epsilon} (q_{0}) &, \text{ if } w = \epsilon \\
\overline{\epsilon} \big(\bigcup_{p\in \hat{\delta'}(q _{0}, x)} \delta (p,a)\big) &, \text{ if } w = xa
\end{cases}
\end{equation}
\end{definition}

\subsubsection{空转 NFA 的性质}
实际上 \(\epsilon\) - NFA 也是和 NFA 等价的, 这就是说给定一个 \(\epsilon\) - NFA , 我们能够构造出一个 NFA. 且有 \(L (N )  = L (N ' ) \). 
\begin{thm}[\(\epsilon\)-NFA 和 DFA 等价性] 
\end{thm}
\subsubsection{空转 NFA 转换为 DFA}
方法是和前面类似的. % TODO 


\end{document}
