\documentclass[../main_part1.tex]{subfiles}
\begin{document}

我们这边的题型是如何判定一个语言不是正则的. 既然他这么问了, 那么他大概率不是正则的. 
\section{泵引理和泵引理的证明}\label{sec:beng}
所用到的方法便是下面介绍的泵引理. 需要注意到, 符合泵引理的语言不一定是正则的, 但不满足的一定不是正则的, 也就是说, 泵引理实际上是正则的必要条件. 
\paragraph{鸽巢原理}
原理应该很简单, 之前在其他地方也有涉及\footnote{比如说, 线性代数之中有一题: 证明对于一个 \(n\) 阶方阵, 存在 \(k \le n\) 使得 \(r (A ^{k} )= r (A ^{k + 1} ) = r (A ^{k + 2} ) = \dots\)}, 其实是一个挺有意思的定理. 

\paragraph{泵引理} 泵的意思是, 正则语言之中的有些语句之中某些部分, 能够被泵出来. 若是 \(w = x y z \) 是满足这个条件的, 就有 \( y\) 可以被泵出来, 也就是 \( w^{i}   =  x y ^{i} z \) , \( i  = 1 , 2 , \dots \), 也有 \(w \in L \). 所以形象地称呼其为泵引理. 

\begin{thm}
	对于正则语言 \(L\), 存在 \(N\) 使得对于长度大于等于 \(N\) 的语句, i.e. \(w \mid |w | \ge N\) , 可以分为三个部分 \(xyz\), i.e. \(w = xyz\), 并且满足: 
\begin{itemize}
\item [1.] \(y \ne \epsilon\), 这是说泵出的部分不能为空
\item [2.] \(|xy | \le N\), 这描述了 \(y\) 的位置. 
\item [3.] \(x y^{*} z \in L\), 这是说 \(y\) 可以被泵. 
\end{itemize}
\end{thm}

\paragraph{证明}
证明需要用到前面的定理.  

考虑这个语言对应的 DFA. 并且给定了 DFA 的状态编号. 并且设 \(N\) 为状态的数目.  

设 \(w = a_{1} a_{2} a_{3} \dots a_{m}\), \(m \ge N\), \(q_{i} = \hat{\delta} (q_{0} , a_{1} \dots a_{i})\). \(q_{i}\) 代表的是, DFA 接收到 \(w\) 的前 \(i\) 字母的时候所处于的状态. 这个证明的重点在于: 使用鸽巢原理知道, 至少存在一对 \(i, j\), \(i \ne j\), \( 0 \le  i , j \le N\), 使得 \(q_{i} = q_{j}\)\footnote{当 \( i = N\) 的时候, 经过的状态已经达到了 \(N  + 1\) 个.}. 

我们设 \( (q_n , q_{m})\) 代表状态 \(q _{n}\) 到 \(q _{m}\) 需要的字符串集合, viz., \(w  \in  (q _{n}, q _{m})\iff \hat\delta (q_{n}, w) =  q_{m} \), 那么我们有 \[ (q _{n}, q_{m}) = ( q _{n} ,  q_{n}) ^{*}(q_{n} , q_{m}) \]
那么我们知道 \(w\) 之中 \(i, j\) 之间的字符串 \(w _{i, j} \in (q _{i} , q _{i})\), 那么 
\[ w_{i+1 , j} ^{*}  w _{j + 1, m} \in (q_{i}, q_{m})\]
自然有 \(w_{1 , i} w _{i + 1 , j}^{*} w _{j + 1 , m} \in L = (q_{0}, q_{m})\). 
于是自然地, \(\vert w _{i + 1, j}\vert \ne 0 \), 且 \(\vert w _{1, j}\vert \le N\). 

\paragraph{通过泵引理证明某些语言并不是正则的. }
我们称 \(w\) 是满足泵引理的, 如果存在对 \(w\) 的划分 \(x yz\), 都有 \(x y ^{*} z \in L \). 那么我们可以重述泵引理.  
\[
	L \text{ is regular } \implies 
	\exists N \in \mathbb{N}
	\forall w\in L \ , |w | \ge N  (w\text{ 满足泵引理})
\]
取其逆否命题, 就有 
\[
	\neg (\exists N \in \mathbb{N}
	\forall w\in L \ , |w | \ge N  (w\text{ 满足泵引理}) ) 
	\implies 
	L \text{ is not regular}
\]
但是我们有 
\[
\begin{aligned}
	& \neg (\exists N \in \mathbb{N}
	\forall w\in L \ , |w | \ge N  (w\text{ 满足泵引理}) )  \\
	= 
	& \forall N \in \mathbb{N} , \exists w \in L (\forall x, y , z (xyz = w \to (\exists i \in N, xy^{i}z \notin L )))
\end{aligned}
\]
如果说我们证明了这个命题, 那么我们就能够证明 \(L\) 不是正则的. 

\begin{exam}\label{eg:ifelse}
证明 \(L_{01}  = \{ 0 ^{n } 1 ^{n} \mid n \ge 0\}\) 不是正则的. 
\end{exam}
\begin{exam}
证明 \(L = \{ 0 ^{i}  1 ^{j} \mid i > j \} \) 不是正则的. 
\end{exam}
\begin{exam}
证明 \(L = \{ a ^{n !} \mid n \ge 0\}\) 不是正则的. 
\end{exam}

\section{运算的封闭性}\label{sec:feng}
正则语言再某些运算之后得到的新语言仍然是正则的. 
称正则语言再这些运算下封闭. 



并
补
交
差
反转
同态
逆同态
% TODO 逆同态. 


\section{判定正则语言}\label{sec:panding}

% TODO

三个判定问题: 

\(w\) 是否属于描述的语言

语言是否为空是否为无穷的. 

语言的等价性问题. 

对于非空的, 检查全部长度小于 \(n\) 串. 

是否为无穷, 检查全部长度有 \(n\) 到 \(2 n - 1\) 的串. 


\section{DFA 的最小化}\label{sec:}

最小化

将冗余的状态消除

\(\hat\delta (p , w ) \in F \iff\hat\delta ( q , w ) \in F\)

不等价

对于两个状态 \(p, q\) , 存在一个 \(w\) 使得, \( \hat{\delta} (p , w )  , \hat\delta (q, w )\) 其中一个属于 \(F\), 而另一个不是. 

\subsection{填表算法:}\label{sse:table}
1. 基础: \( p \in F , q \notin F\) then \(p , q \) 不等价 .

2. 对于 \(a \in \Sigma\)  if \( r =\delta (p , a ) , s =\delta (q , a ) \) 不等价, 那么 \(p, q \) 不等价. 

和那个数字逻辑里面的差不多. 但是严谨一点.

我们这里有四个步骤. 

\begin{itemize}
\item [1] 首先考虑基础, 初始化 
\item [2] 其次考虑经过 \(0\) 到达终态和非终态的状态对. 
	就是说, 将所有状态分为三类: 1. 输入为 \(0\) 不发生状态转移的; 2. 输入为 \(0\) 到达终态的; 3. 不能到达终态的. 
	考虑后面两类,  \(\{ D , F \} \times \{ A, B , E , G , H \}\) , 其中 \(\times\) 是一个直积. 
\item [3] 类似的, 考虑经过 \(1\) 到达终态和非终态的状态对. 
\item [4] 最后进行对所有空余进行验证, 卧槽, 真几把麻烦.
\end{itemize}

\begin{remark}
	对于状态对, 比如说 \((A , E)\), 考虑 \((\delta (A , 0) ,\delta (E, 0 ) = ( B , H) )\) 这是说, \( (A, E ) \) 不等价取决于 \((B, H) \) 是否等价. 

	考虑 \(( B,  H ) \) , \((\delta (B , 0 ) ,\delta (H , 0 ) ) = (G , G) \) , \( (\delta (B , 1 )  ,\delta (H , 1 ) ) = (C, C)\)
	终态相等, 也是等价的标志. 那么 \(B, H\) 等价. 

	于是 \(A, E\) 也是等价的. 

	我们进行总结, 如果说有两对, 或者以上的状态对, 其等价性相互依赖, 那么可以断言这些状态对等价.  \qed
\end{remark}
% TODO : 屑! 表述还需要进一步完善.

\section{Regular Expressions in Unix}
\label{sec:Regular Expressions in Unix}


% section Regular Expressions in Unix 
\end{document}
