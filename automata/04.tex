\documentclass[../main_part1.tex]{subfiles}
\begin{document}

Contents: 
\begin{itemize}
\item [1] 无关文法 
\item [2] 语法分析树
\item [3]  歧义
\item [4] 文法的化简和范式
\end{itemize}

\section{上下文无关文法}\label{sec:def}
\noindent 例~\ref{eg:ifelse} 告诉我们 \(L = \{ \, 0^{n}1^{n}\mid n \in \mathbb{N} \, \}\) 并不是一个正则语言. 但其为一个\textbf{上下文无关语言}. 并且很有意思的是 \(L = \{ \,  w \mid w \text{ 是正则表达式} \, \}\) 并不是一个正则语言, 也就是说, 正则语言, 并不能描述所有的正则语言.



\begin{exam}[回文]
if \(w \in \Sigma ^{*} , w = w ^{R}\), then \(w\) 为回文
\end{exam}
\begin{exam}[回文语言]
	if \( L =  \{ w \in \Sigma ^{* } \mid w = w ^{R} \}\)
	then L 是回文语言. 
\end{exam}
我们可以使用递归方法定义回文语言, 正如我们定义一阶逻辑之中的命题一样: 
\begin{itemize}
\item [\textbf{1.}] 首先 \(\epsilon, 0 , 1\) 都是回文.
\item [\textbf{2.}] if \(w\) 是回文, 那么 \( 0  w 0 , 1 w 1 \) 都是回文. 
\end{itemize}

\begin{figure}
	\centering
	\begin{tabular}{cccl}
		1. & \(P \) & \(\to\) & \(\epsilon\) \\ 
		2. & \(P\) & \(\to\) & \(0\)\\
		3. & \(P\) & \(\to\) & \(1\)\\
		4. & \(P\) & \(\to\) & \(0P0\)\\
		5. & \(P\) & \(\to\) & \(1P1\)\\
	\end{tabular}
	\caption{A context free grammar for palindromes}
\end{figure}

\begin{definition}[文法]
	文法 \(G\) 是一个 \(4p\) 结构, \(G = (V , T , P , S ) \).
	其中 \(V \) for variable, \(T\) for terminator, \(P\) for Production, \(S\) for start.
	\begin{itemize}
	\item [1]  \(V\) 是变量的集合. 
	\item [2]  \(T\) 称为 terminators. 
	\item [3]  \(P\) 是生产规则, 形式为 \(A \to\alpha \mid\beta\), 其中 \(\alpha ,\beta \in (V \cup T ) ^{*}\) 
	\item [4]  \( S \in V\), 表示的是初始变量.
	\end{itemize}
\end{definition}

\begin{exam}[\(0,1\) 组成的回文]
	\(G = (V , T , P , S ) \) , 其中 \(V = \{ A \} \), \(T = \{ 0 , 1 \} \), \(P = A \to \epsilon \mid 0 \mid 1\mid  0A 0 \mid 1 A1\) , \(S = A\)
\end{exam}
\begin{exam}[\(0 ^{n}1 ^{n}\)]
	\(L = \{  0 ^{ n} 1 ^{n} \mid n \in \mathbb{N} \} \)
	和上面一个完全类似, 这里就懒得说了
\end{exam}
\begin{exam}
	算术表达式, 比如说 \( a + b \), \( a * b + a\), 或者是有 \(0\) 或者 \(1\) 的式子, 比如说 \( 1 + a * 0\) 等等. 这些式子的语言就不是正则的. 在文法的构造之中用到了两个变量 \(E\), \(I\). 其中 \(E\) for Expression; \(I\).
\end{exam}

\subsection{归约和派生}
\marginpar{inference 规约\\ 
derivation 派生\\
多步派生\\
左派生和右派生}
\begin{quotation}
Inference is the construction of a string using productions of the grammar. It is a construction \textbf{from body to head}. Which is to say that we are given some strings that are known to be the string in the grammar, and then use them to construct 
another string that is in the grammar. 

	Meanwhile, derivation is the construction \textbf{from head to body}, from the initial variable, we use productions in the grammar to substitute the variable with strings in \( (V\cup T) ^{*}\). 
\end{quotation}
\begin{definition}[派生]
	\(\alpha ,\beta , \gamma \in (V \cup T ) ^{*}\) , if \(A \to \gamma\), then \( \alpha A\beta \underset{G}{\Rightarrow}\alpha \gamma\beta\). 
\end{definition}

\begin{definition}[文法派生的句型]
\(\alpha \in (V \cup T ) ^{*} \) , \(\alpha\) 是变元可能派生出的语句. 比如说 \(A \to\alpha\), 那么 \(\alpha\) 就是一个句型, 而后如果 \(\alpha\) 继续派生的得到了 \(\beta\), 那么 \(\beta\) 也是一个句型. 
\end{definition}

\begin{definition}[归约]
	以算术表达式为例, 如果说 \(w \) 是 \(I\), 那么 \(aw\), \(bw\), \(0w\), \(1w\) 也是 \(I\), 如果说 \(w' , w''\) 是 \(E\), 那么 \( w' \cdot w''\), \( w' + w''\), \( (w')\) 都是 \(E\). 这种自底向上的构造法就是归约. 
\end{definition}

\begin{exam}[派生的例子]
% TODO 派生的例子, 见 ppt
\end{exam}

\begin{definition}[多步派生]
	\begin{equation}
		\alpha_{1} \overset{i}{\underset{G}{\Rightarrow}} \alpha _{1 + i}
	\end{equation}
	对于一般的多步派生, 记为 \(\overset{*}{\underset{G}{\Rightarrow}}\). 特别地, 还有零步派生 \(\alpha \overset{*}{\Rightarrow}\alpha\).
\end{definition}

\begin{definition}[最左派生, 最右派生]
	对于一个句型 \(\alpha\), 我们考虑只对最左(右)的变量进行派生, 这就是最左(右)派生. 记为 \(\underset{lm}{\Rightarrow}\) (\(\underset{rm}{\Rightarrow}\)). 为了取消歧义. 
\end{definition}
\begin{thm}[派生的\textbf{等价性}]
对于任意一个派生, 都存在一个最左 (右) 派生与其对应
\end{thm}

\subsection{文法的语言}
\marginpar{\(L = \{ \, w\mid 0,1 \text{ 数量相等} \, \}\)\\
\(L = \{ \, a^{n}, b^{n} \mid n \in \mathbb{N} \, \}\)}
\begin{definition}[语言]
\begin{equation}
	L (G) =  \{ w \mid w \in T ^{*} , S \overset{*}{\underset{G}{\Rightarrow}} w \}
\end{equation}
\end{definition}

\begin{remark}[为什么称为是上下文无关文法]
	我们参考 \(\alpha A\beta \underset{G}{\Rightarrow}\alpha\gamma\beta\), 这个派生是否成立, 是跟 \(\alpha ,\beta\) 无关的, 于是称为上下文无关文法.
\end{remark}

\begin{definition}[等价性]
	\(G_{1} , G_{2}\) 满足 \(L (G _{1} )  =  L (G _{2} ) \) , 则 \(G_{1} \) 等价于 \(G_{2}\)
\end{definition}

\begin{definition}[句型, 左句型, 右句型]
	\(G\) 生成的句型定义如下: 
	\begin{equation}
		\{ w \mid w \in (V \cup T ) ^{*} , S \overset{*}{\underset{G}{\Rightarrow}} w \}
	\end{equation}
	也定义了左句型, 右句型.
\end{definition}


\begin{exam}
	\(L  = \{ a ^{n} b ^{n}\mid n \ge 1 \}\)
\end{exam}
\begin{exam}
	\(G = \{ \}\)
\end{exam}
\begin{exam}
	\(L = \{  w \mid 0,  1 \text{ 数量相等}\}\), G = \((V, T , P , S)\), 其中 \(V = \{ S \}, T = \{ 0 ,1 \}\), \(P \) 是下面这个:
	\[
	S \to 0S 1 S \mid 1 S 0 S  \mid \epsilon 
\]
如何证明其对应的语言确实是 \(L\)? 我们需要验证, 对于 \(L\) 之中的任意一个字符串 \(w\) 确实能够如此划分, 使得 \(w = 0 w' 1 w''\), 其中 \(w '\), \(w ''\) 都是 \(L\) 的. 使用分类讨论即可证明这一点. 
\end{exam}

\begin{exam}[算术表达式]
\end{exam}


\section{语法分析树}\label{sec:tree}
\marginpar{sparse tree 分析树\\
Pump Lemma 泵引理\\
Sparse Tree 和 inference 和 derivation 之间的等价性}
语法分析树是表示派生过程的一个树. 此后在 Context free language 的泵引理的证明之中要用到. 
\begin{definition}[分析树]\label{def:分析树}
定义为 
\begin{itemize}
\item [1] 
 每个内节点是边缘符号
\item [2] 
叶子节点是 \(V \cup T \cup \{ \epsilon \} \) 之中的符号 
\item [3] 
如果说内节点的标记是 \(A\), 那么其子节点从左到右分别为
\[
X_{1} , X _{2}, \dots , X _{n}
\]
那么 \(A \to X _{1} X _{2}\dots  X_{n}\) 是一个产生式.\qed 
\end{itemize}
\end{definition}
% definition: 分析树

如果说, 根节点是初始符号 \(s\), 叶子节点是终结符, 那么该树是完成的, 该树的产物属于 \(L (G) \). 
\begin{definition}[subtree]\label{def:subtree}
在树 \(T\) 之中以内节点 \(A\) 为根节点的 subtree 为 \(T\) 的 subtree
\end{definition}
% definition: subtree

\begin{thm}[the equivalence of tree]
	一棵树和 \(L (G)\)之中的一个语句等价. 

	1. \(G\) 存在 \(A\) 为根节点的树, 其产物为 \(\alpha\), then \(A \overset{*}{\Rightarrow}\alpha\)

	2. 如果说 \(A \overset{*}{\Rightarrow}\alpha\) then 存在 \(A\) 为根的树, 其产物为 \(\alpha\)
\end{thm}
\begin{proof}
% TODO 我觉得有问题, 充分有问题
\end{proof}

% sec:tree

\section{文法和语言的歧义性}\label{sec:文法和语言的歧义性}
\marginpar{歧义性\\ 
歧义性和算法}
\noindent 算术表达式的语言中 \(L_{\text{exp}}\), 比如说 \(w = 1 * 1 + 1\), 有两个生成树. 此为\textbf{歧义}.


\begin{exam}[表示加法乘法的优先级]
	Fig~\ref{fig:exp} 展示了 \(G_{\text{exp}}\) 的产生式, \(G _{\text{exp}}\) 是歧义的, 因为存在一个语句有两个 Sparse Tree.
\begin{figure}
	\centering
	\begin{tabular}{cccl}
		1. & \(P \) & \(\to\) & \(\epsilon\) \\ 
		2. & \(P\) & \(\to\) & \(0\)\\
		3. & \(P\) & \(\to\) & \(1\)\\
		4. & \(P\) & \(\to\) & \(0P0\)\\
		5. & \(P\) & \(\to\) & \(1P1\)\\
	\end{tabular}
	\caption{A context free grammar for palindromes}
	\label{fig:exp}
\end{figure}
\end{exam}

\begin{definition}[固有歧义]\label{def:固有歧义}
	对于一些语言, 其对应的文法都是有歧义的.
\end{definition}
% definition: 固有歧义

\begin{exam}
	对于 \(L = \{ a ^{i }  b ^{j} c ^{k} \mid i =  j \text{ or } j = k \} \), \(L\) 是固有歧义的. 

	需要知道的是, 固有歧义的证明非常繁琐, 甚至很难理解. 并且, 并不存在算法能够验证任意一个语言是固有歧义的. 
\end{exam}

% section 文法和语言的歧义性

\section{文法的化简和设计}
\label{sec:文法的化简和设计}
% TODO 引入
\subsection{化简}
\marginpar{Useless \\
\(\epsilon\)-productions\\
unit productions}

\begin{itemize}
\item [1] 
消除无用符号
\item [2] 
消除 \( \epsilon\) 产生式 (\( \epsilon\) production)
\item [3] 
消除单元产生式 (unit production) :\(A \to B\)
\end{itemize}

\subsubsection{无用符号的消除}
我们将一些无用的符号进行化简, 分为两类, 一类是不可达的, 一类是不可产生的, 这两种符号都是没有用的, 这是说, 对于一个语句的派生过程, 这些符号是不会出现的. 所以说是无用符号. 下面给出定义. 
\begin{definition}[Useful]\label{def:Useful}
对于 \(G = (V , T , P , S)\) , 符号 \(X \in (V \cup T )\). 
\begin{enumerate}
\item  如果 \(G \overset{*}{\Rightarrow}\alpha X\beta\) then \(X\) is \textbf{reachable}. 
\item  if \(\alpha X\beta \overset{*}{\Rightarrow} w \in T ^{*}\)  then \(X\) is \textbf{generating}. 
\item  If \(X\) is reachable and generating, then \(X\) is \textbf{useful}. \(X\) is useless otherwise. 
\end{enumerate}
\end{definition}
% definition: Useful
\begin{remark}
\(T\) is generating, while \(S\) is reachable. You can easily prove it.
\end{remark}

\begin{exam}
	对于 \(P =\{ S \to A B \mid a , A \to b\} \)
	可达的符号机和产生的符号分别为什么? 
\end{exam}
\begin{proof}
	\(T = \{ a, b \} , A, S\) 是产生的, \(S , A , B , a, b\) 是可达的, 
\end{proof}
\begin{remark}
能够看出, 我们要找到产生的, 则需要\textbf{从后往前找}, 若是要找到可达的, 则需要\textbf{从前往后找}. 
\end{remark}
%subsubsection:无用符号的消除

\subsubsection{\(\epsilon\) 产生式}
如果说 \(A \Rightarrow \epsilon\), 称 \(A\) 是可空的. \( \epsilon\) 产生式除了贡献 \(L\) 中的 \( \epsilon\) 之外没有任何作用, 于是说, 当 \(L \) 之中没有 \( \epsilon\) 的时候, 我们就可以将 \(G\) 之中的 \( \epsilon\) 产生式消除掉. 这 (大概) 就是原理. 
\begin{definition}[可空变元]\label{def:可空变元}
% TODO 可空变元
\end{definition}
% definition: 可空变元

\begin{exam}
	消除 \(G = ( \{ S ,A , B \} , \{ a, b \} , P , S )\) 的 \( \epsilon\) 产生式. 
	\begin{equation}
	\begin{aligned}
		P = \{ & S \to A B  , \\ 
		       & A \to A a A \mid \epsilon \\
		       & B \to B b B \mid \epsilon \}
	\end{aligned}
	\end{equation}
\end{exam}

\begin{exam}
	\(G_{2} = ( \{ S , A  , B , C \} , \{ a, b \} , P , S )\) 
	\begin{equation}
	\begin{aligned}
		P = \{ & S \to A B C , \\ 
		       & A \to a A \mid \epsilon , \\ 
		       & B \to b B \mid \epsilon , \\
		       & C \to \epsilon \}
	\end{aligned}
	\end{equation}
\end{exam}

% subsubsection: \( \epsilon\) 产生式

\subsubsection{单元产生式的消除}
If \(A \overset{*}{\Rightarrow} B\) then \(A, B\) are equivalent. You may view \(A, B\) as the same variable and merge the relative productions.

\begin{exam}
	\begin{equation}
	\begin{aligned}
		P = \{ & S \to A \mid B \mid 0S 1 , \\ 
		       & A \to 0 A \mid 0 ,  \\ 
		       & B \to 1 B \mid 1 \}
	\end{aligned}
	\end{equation}
\end{exam}
\begin{proof}
It is easy to note that \(S, A , B \) are equivalent. Then 
\(P = \{ S \to 0S1 \mid 0 S \mid 0 \mid 1 S \mid 1\}\)
\end{proof}
% subsubsection:单元产生式的消除

\subsubsection{化简步骤}

\begin{enumerate}
\item [1]  消除\(\epsilon\)产生式
\item [2]  reduce the unit productions
\item [3] Reduce the not generating productions
\item [4] Reduce the not reachable productions
\end{enumerate}
% subsubsection:化简步骤 

% subsection:化简
% section 文法的化简和设计 
\end{document}
