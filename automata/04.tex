\documentclass[../main.tex]{subfiles}
\begin{document}
\tableofcontents
Contents: 
\begin{itemize}
\item [1] 无关文法 
\item [2] 语法分析树
\item [3]  歧义
\item [4] 文法的化简和范式
\end{itemize}

\section{上下文无关文法}\label{sec:def}
考虑前面学过的, \(\{  0 ^{n} 1 ^{n} \mid n \in \mathbb{N}\}\) 不是正则表达式的语言. 



\begin{exam}[回文]
if \(w \in \Sigma ^{*} , w = w ^{R}\), then \(w\) 为回文
\end{exam}

\begin{exam}[回文语言]
	if \( L =  \{ w \in \Sigma ^{* } \mid w = w ^{R} \}\)
	then L 是回文语言. 
\end{exam}
运用前面的知识, 可以使用 Pump lemma 证明 \(L\) 不是正则的. 可是那么我们该如何表示该语言呢? 

可以使用递归方法定义: 
\begin{itemize}
\item [\textbf{1.}] 首先 \(\epsilon, 0 , 1\) 都是回文.
\item [\textbf{2.}] if \(w\) 是回文, 那么 \( 0  w 0 , 1 w 1 \) 都是回文. 
\end{itemize}
数理逻辑之中, 命题的递归定义也是类似的, 这种生成语句的规则就是上下文无关文法. 




\begin{equation}
\left.
\begin{aligned}
&1. A \to\epsilon \\ 
&2. A \to 0 \\ 
&3. A \to 1 \\ 
&4. A \to 0 A 0 \\ 
&5. A \to 1A1
\end{aligned}
\right\}
\end{equation}

\begin{definition}[文法]
	文法 \(G\) 是一个 \(4p\) 结构, \(G = (V , T , P , S ) \).
	其中 \(V \) for variable, \(T\) for terminator, \(P\) for Production, \(S\) for start.
	\begin{itemize}
	\item [1]  \(V\) 是变量的集合. 
	\item [2]  \(T\) 称为 terminators. 
	\item [3]  \(P\) 是生产规则, 形式为 \(A \to\alpha \mid\beta\), 其中 \(\alpha\) 是 \( \epsilon \) 或者是 \(\alpha \in T \), 或者是 \(\alpha \in E \), 或者是 \(\alpha \in (V\cup T )^{*} \), \(\beta \) 也是如此. 
	\item [4]  \( S \in V\), 表示的是开始的变量, 所有句型, 语句都是从 \( S\) 开始派生的. 
	\end{itemize}
\end{definition}

\begin{exam}[\(0,1\) 组成的回文]
	\(G = (V , T , P , S ) \) , 其中 \(V = \{ A \} \), \(T = \{ 0 , 1 \} \), \(P = A \to \epsilon \mid 0 \mid 1\mid  0A 0 \mid 1 A1\) , \(S = A\)
\end{exam}
\begin{exam}[\(0 ^{n}1 ^{n}\)]
	\(L = \{  0 ^{ n} 1 ^{n} \mid n \in \mathbb{N} \} \)
	和上面一个完全类似, 这里就懒得说了
\end{exam}

\subsection{归约和派生}
\begin{definition}[文法派生的句型]
\(\alpha \in (V \cup T ) ^{*} \) , \(\alpha\) 可能是派生出的语句. 
因为考虑到 \(A \to t\), \(t \in T\), 或者是 \(A \to A t \) . 也就是说, 这个语句里面只会有 variable or terminator.
\end{definition}

\begin{definition}[归约]
\end{definition}

\begin{definition}[派生]
	\(\alpha ,\beta , \gamma \in (V \cup T ) ^{*}\) , if \(A \to \gamma\), then \( \alpha A\beta \underset{G}{\Rightarrow}\alpha \gamma\beta\). 
\end{definition}
\begin{exam}[派生的例子]
% TODO 派生的例子, 见 ppt
\end{exam}

\begin{definition}[多步派生]
	\begin{equation}
		\alpha_{1} \overset{i}{\underset{G}{\Rightarrow}} \alpha _{1 + i}
	\end{equation}
	对于一般的多步派生, 记为 \(\overset{*}{\underset{G}{\Rightarrow}}\)
\end{definition}

\begin{definition}[最左派生, 最右派生]
	对于一个句型 \(\alpha\), 我们考虑只对最左(右)的变量进行派生, 这就是最左(右)派生. 记为 \(\underset{lm}{\Rightarrow}\) (\(\underset{rm}{\Rightarrow}\))
\end{definition}
\begin{thm}[派生的\textbf{等价性}]
对于任意一个派生, 都存在一个最左 (右) 派生与其对应
\end{thm}

\subsection{文法的语言}

\begin{definition}[语言]
\begin{equation}
	L (G) =  \{ w \mid w \in T ^{*} , S \overset{*}{\underset{G}{\Rightarrow}} w \}
\end{equation}
\end{definition}

\begin{remark}[为什么称为是上下文无关文法]
	我们参考 \(\alpha A\beta \underset{G}{\Rightarrow}\alpha\gamma\beta\), 这个派生是否成立, 是跟 \(\alpha ,\beta\) 无关的, 于是称为上下文无关文法.
\end{remark}

\begin{definition}[等价性]
	\(G_{1} , G_{2}\) 满足 \(L (G _{1} )  =  L (G _{2} ) \) , 则 \(G_{1} \) 等价于 \(G_{2}\)
\end{definition}

\begin{definition}[句型, 左句型, 右句型]
	\(G\) 生成的句型定义如下: 
	\begin{equation}
		\{ w \mid w \in (V \cup T ) ^{*} , S \overset{*}{\underset{G}{\Rightarrow}} w \}
	\end{equation}
	也定义了左句型, 右句型.
\end{definition}


\begin{exam}
	\(L  = \{ a ^{n} b ^{n}\mid n \ge 1 \}\)
\end{exam}
\begin{exam}
	\(G = \{ \}\)
\end{exam}
\begin{exam}
	\(L = \{  w \mid 0,  1 \text{ 数量相等}\}\), G = \((V, T , P , S)\), 其中 \(V = \{ S \}, T = \{ 0 ,1 \}\), \(P \) 是下面这个:
	\[
	S \to 0S_{1} 1 S_{2} \mid 1 S_{1} 0 S_{2}  \mid \epsilon 
\]
\end{exam}

\begin{exam}[算术表达式]
\end{exam}


\section{语法分析树}\label{sec:tree}

语法分析树是表示派生过程的一个树

\begin{definition}[分析树]\label{def:分析树}
定义为 
\begin{itemize}
\item [1] 
 每个内节点是边缘符号
\item [2] 
叶子节点是 \(V \cup T \cup \{ \epsilon \} \) 之中的符号 
\item [3] 
如果说内节点的标记是 \(A\), 那么其子节点从左到右分别为
\[
X_{1} , X _{2}, \dots , X _{n}
\]
那么 \(A \to X _{1} X _{2}\dots  X_{n}\) 是一个产生式. 
\end{itemize}
注意到空船. 
\end{definition}
% definition: 分析树

如果说, 根节点是初始符号 \(s\), 叶子节点是终结符, 那么该树是完成的, 该树的产物属于 \(L (G) \). 
\begin{definition}[subtree]\label{def:subtree}
在树 \(T\) 之中以内节点 \(A\) 为根节点的 subtree 为 \(T\) 的 subtree
\end{definition}
% definition: subtree

\begin{thm}[the equivalence of tree]
	一棵树和 \(L (G)\)之中的一个语句等价. 

	1. \(G\) 存在 \(A\) 为根节点的树, 其产物为 \(\alpha\), then \(A \overset{*}{\Rightarrow}\alpha\)

	2. 如果说 \(A \overset{*}{\Rightarrow}\alpha\) then 存在 \(A\) 为根的树, 其产物为 \(\alpha\)
\end{thm}
\begin{proof}
% TODO 我觉得有问题, 充分有问题
\end{proof}

% sec:tree

\section{文法和语言的歧义性}\label{sec:文法和语言的歧义性}

对于 \(G\) 之中某些语句有不同的语法分析树, 则 \(G\) 是有歧义的.

比如说对于算术表达式的文法 \(G_{exp}\) 之中 \(a \cdot a  +  a\) 之中, \textbf{有多种的阅读顺序}, 这就导致了歧义. 

\begin{exam}[表示加法乘法的优先级]
我们考虑 \(P\)
\begin{equation}
\begin{aligned}
	P  = \{  &E \to E + T \mid T ,\\ 
	  &T \to T \cdot F \mid F , \\
	  &F \to (E) \mid I \}
\end{aligned}
\end{equation}
% TODO
\end{exam}

\begin{definition}[固有歧义]\label{def:固有歧义}
	对于一些语言, 其对应的文法都是有歧义的.
\end{definition}
% definition: 固有歧义

\begin{exam}
	对于 \(L = \{ a ^{i }  b ^{j} c ^{k} \mid i =  j \text{ or } j = k \} \), \(L\) 是固有歧义的. 
\end{exam}

% section 文法和语言的歧义性

\section{文法的化简和设计}
\label{sec:文法的化简和设计}
% TODO 引入
\subsection{化简}

\begin{itemize}
\item [1] 
消除无用符号
\item [2] 
消除 \( \epsilon\) 产生式 (\( \epsilon\) production)
\item [3] 
消除单元产生式 (unit production) :\(A \to B\)
\end{itemize}

\subsubsection{无用符号的消除}
我们将一些无用的符号进行化简, 分为两类, 一类是不可达的, 一类是不可产生的, 这两种符号都是没有用的, 这是说, 对于一个语句的派生过程, 这些符号是不会出现的. 所以说是无用符号. 下面给出定义. 
\begin{definition}[Useful]\label{def:Useful}
对于 \(G = (V , T , P , S)\) , 符号 \(X \in (V \cup T )\). 
\begin{enumerate}
\item  如果 \(G \overset{*}{\Rightarrow}\alpha X\beta\) then \(X\) is \textbf{reachable}. 
\item  if \(\alpha X\beta \overset{*}{\Rightarrow} w \in T ^{*}\)  then \(X\) is \textbf{generating}. 
\item  If \(X\) is reachable and generating, then \(X\) is \textbf{useful}. \(X\) is useless otherwise. 
\end{enumerate}
\end{definition}
% definition: Useful
\begin{remark}
\(T\) is generating, while \(S\) is reachable. You can easily prove it.
\end{remark}

\begin{exam}
	对于 \(P =\{ S \to A B \mid a , A \to b\} \)
	可达的符号机和产生的符号分别为什么? 
\end{exam}
\begin{proof}
	\(T = \{ a, b \} , A, S\) 是产生的, \(S , A , B , a, b\) 是可达的, 
\end{proof}
\begin{remark}
能够看出, 我们要找到产生的, 则需要\textbf{从后往前找}, 若是要找到可达的, 则需要\textbf{从前往后找}. 
\end{remark}
%subsubsection:无用符号的消除

\subsubsection{\(\epsilon\) 产生式}
如果说 \(A \Rightarrow \epsilon\), 称 \(A\) 是可空的. \( \epsilon\) 产生式除了贡献 \(L\) 中的 \( \epsilon\) 之外没有任何作用, 于是说, 当 \(L \) 之中没有 \( \epsilon\) 的时候, 我们就可以将 \(G\) 之中的 \( \epsilon\) 产生式消除掉. 这 (大概) 就是原理. 
\begin{definition}[可空变元]\label{def:可空变元}
% TODO 可空变元
\end{definition}
% definition: 可空变元

\begin{exam}
	消除 \(G = ( \{ S ,A , B \} , \{ a, b \} , P , S )\) 的 \( \epsilon\) 产生式. 
	\begin{equation}
	\begin{aligned}
		P = \{ & S \to A B  , \\ 
		       & A \to A a A \mid \epsilon \\
		       & B \to B b B \mid \epsilon \}
	\end{aligned}
	\end{equation}
\end{exam}

\begin{exam}
	\(G_{2} = ( \{ S , A  , B , C \} , \{ a, b \} , P , S )\) 
	\begin{equation}
	\begin{aligned}
		P = \{ & S \to A B C , \\ 
		       & A \to a A \mid \epsilon , \\ 
		       & B \to b B \mid \epsilon , \\
		       & C \to \epsilon \}
	\end{aligned}
	\end{equation}
\end{exam}

% subsubsection: \( \epsilon\) 产生式

\subsubsection{单元产生式的消除}
If \(A \Rightarrow B\) then \(A, B\) are equivalent. You may view \(A, B\) as a same variable and merge the relative productions.

\begin{exam}
	\begin{equation}
	\begin{aligned}
		P = \{ & S \to A \mid B \mid 0S 1 , \\ 
		       & A \to 0 A \mid 0 ,  \\ 
		       & B \to 1 B \mid 1 \}
	\end{aligned}
	\end{equation}
\end{exam}
\begin{proof}
It is easy to note that \(S, A , B \) are equivalent. Then 
\(P = \{ S \to 0S1 \mid 0 S \mid 0 \mid 1 S \mid 1\}\)
\end{proof}
% subsubsection:单元产生式的消除

\subsubsection{化简步骤}

\begin{enumerate}
\item [1]  消除\(\epsilon\)产生式
\item [2]  reduce the unit productions
\item [3] Reduce the not generating productions
\item [4] Reduce the not reachable productions
\end{enumerate}
% subsubsection:化简步骤 

% subsection:化简
% section 文法的化简和设计 
\end{document}
